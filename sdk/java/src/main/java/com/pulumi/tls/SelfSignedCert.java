// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.tls;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.tls.SelfSignedCertArgs;
import com.pulumi.tls.Utilities;
import com.pulumi.tls.inputs.SelfSignedCertState;
import com.pulumi.tls.outputs.SelfSignedCertSubject;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Creates a **self-signed** TLS certificate in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
 * 
 * &gt; **Warning** Self-signed certificates are usually used only in development environments
 * or applications deployed internally to an organization.
 * Certificates of this type are generally not trusted by client software such
 * as web browsers. Therefore clients are likely to generate trust warnings when
 * connecting to a server that has a self-signed certificate.
 * 
 * ## Example Usage
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.tls.SelfSignedCert;
 * import com.pulumi.tls.SelfSignedCertArgs;
 * import com.pulumi.tls.inputs.SelfSignedCertSubjectArgs;
 * import com.pulumi.std.StdFunctions;
 * import com.pulumi.std.inputs.FileArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new SelfSignedCert("example", SelfSignedCertArgs.builder()
 *             .privateKeyPem(StdFunctions.file(FileArgs.builder()
 *                 .input("private_key.pem")
 *                 .build()).result())
 *             .subject(SelfSignedCertSubjectArgs.builder()
 *                 .commonName("example.com")
 *                 .organization("ACME Examples, Inc")
 *                 .build())
 *             .validityPeriodHours(12)
 *             .allowedUses(            
 *                 "key_encipherment",
 *                 "digital_signature",
 *                 "server_auth")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Automatic Renewal
 * 
 * This resource considers its instances to have been deleted after either their validity
 * periods ends (i.e. beyond the `validityPeriodHours`)
 * or the early renewal period is reached (i.e. within the `earlyRenewalHours`):
 * when this happens, the `readyForRenewal` attribute will be `true`.
 * At this time, applying the Terraform configuration will cause a new certificate to be
 * generated for the instance.
 * 
 * Therefore in a development environment with frequent deployments it may be convenient
 * to set a relatively-short expiration time and use early renewal to automatically provision
 * a new certificate when the current one is about to expire.
 * 
 * The creation of a new certificate may of course cause dependent resources to be updated
 * or replaced, depending on the lifecycle rules applying to those resources.
 * 
 */
@ResourceType(type="tls:index/selfSignedCert:SelfSignedCert")
public class SelfSignedCert extends com.pulumi.resources.CustomResource {
    /**
     * List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `anyExtended`, `certSigning`, `clientAuth`, `codeSigning`, `contentCommitment`, `crlSigning`, `dataEncipherment`, `decipherOnly`, `digitalSignature`, `emailProtection`, `encipherOnly`, `ipsecEndSystem`, `ipsecTunnel`, `ipsecUser`, `keyAgreement`, `keyEncipherment`, `microsoftCommercialCodeSigning`, `microsoftKernelCodeSigning`, `microsoftServerGatedCrypto`, `netscapeServerGatedCrypto`, `ocspSigning`, `serverAuth`, `timestamping`.
     * 
     */
    @Export(name="allowedUses", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> allowedUses;

    /**
     * @return List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `anyExtended`, `certSigning`, `clientAuth`, `codeSigning`, `contentCommitment`, `crlSigning`, `dataEncipherment`, `decipherOnly`, `digitalSignature`, `emailProtection`, `encipherOnly`, `ipsecEndSystem`, `ipsecTunnel`, `ipsecUser`, `keyAgreement`, `keyEncipherment`, `microsoftCommercialCodeSigning`, `microsoftKernelCodeSigning`, `microsoftServerGatedCrypto`, `netscapeServerGatedCrypto`, `ocspSigning`, `serverAuth`, `timestamping`.
     * 
     */
    public Output<List<String>> allowedUses() {
        return this.allowedUses;
    }
    /**
     * Certificate data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format. **NOTE**: the [underlying](https://pkg.go.dev/encoding/pem#Encode) [libraries](https://pkg.go.dev/golang.org/x/crypto/ssh#MarshalAuthorizedKey) that generate this value append a `\n` at the end of the PEM. In case this disrupts your use case, we recommend using `trimspace()`.
     * 
     */
    @Export(name="certPem", refs={String.class}, tree="[0]")
    private Output<String> certPem;

    /**
     * @return Certificate data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format. **NOTE**: the [underlying](https://pkg.go.dev/encoding/pem#Encode) [libraries](https://pkg.go.dev/golang.org/x/crypto/ssh#MarshalAuthorizedKey) that generate this value append a `\n` at the end of the PEM. In case this disrupts your use case, we recommend using `trimspace()`.
     * 
     */
    public Output<String> certPem() {
        return this.certPem;
    }
    /**
     * List of DNS names for which a certificate is being requested (i.e. certificate subjects).
     * 
     */
    @Export(name="dnsNames", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> dnsNames;

    /**
     * @return List of DNS names for which a certificate is being requested (i.e. certificate subjects).
     * 
     */
    public Output<Optional<List<String>>> dnsNames() {
        return Codegen.optional(this.dnsNames);
    }
    /**
     * The resource will consider the certificate to have expired the given number of hours before its actual expiry time. This can be useful to deploy an updated certificate in advance of the expiration of the current certificate. However, the old certificate remains valid until its true expiration time, since this resource does not (and cannot) support certificate revocation. Also, this advance update can only be performed should the Terraform configuration be applied during the early renewal period. (default: `0`)
     * 
     */
    @Export(name="earlyRenewalHours", refs={Integer.class}, tree="[0]")
    private Output<Integer> earlyRenewalHours;

    /**
     * @return The resource will consider the certificate to have expired the given number of hours before its actual expiry time. This can be useful to deploy an updated certificate in advance of the expiration of the current certificate. However, the old certificate remains valid until its true expiration time, since this resource does not (and cannot) support certificate revocation. Also, this advance update can only be performed should the Terraform configuration be applied during the early renewal period. (default: `0`)
     * 
     */
    public Output<Integer> earlyRenewalHours() {
        return this.earlyRenewalHours;
    }
    /**
     * List of IP addresses for which a certificate is being requested (i.e. certificate subjects).
     * 
     */
    @Export(name="ipAddresses", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> ipAddresses;

    /**
     * @return List of IP addresses for which a certificate is being requested (i.e. certificate subjects).
     * 
     */
    public Output<Optional<List<String>>> ipAddresses() {
        return Codegen.optional(this.ipAddresses);
    }
    /**
     * Is the generated certificate representing a Certificate Authority (CA) (default: `false`).
     * 
     */
    @Export(name="isCaCertificate", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> isCaCertificate;

    /**
     * @return Is the generated certificate representing a Certificate Authority (CA) (default: `false`).
     * 
     */
    public Output<Boolean> isCaCertificate() {
        return this.isCaCertificate;
    }
    /**
     * Name of the algorithm used when generating the private key provided in `privateKeyPem`.
     * 
     */
    @Export(name="keyAlgorithm", refs={String.class}, tree="[0]")
    private Output<String> keyAlgorithm;

    /**
     * @return Name of the algorithm used when generating the private key provided in `privateKeyPem`.
     * 
     */
    public Output<String> keyAlgorithm() {
        return this.keyAlgorithm;
    }
    /**
     * Maximum number of intermediate certificates that may follow this certificate in a valid certification path. If `isCaCertificate` is `false`, this value is ignored.
     * 
     */
    @Export(name="maxPathLength", refs={Integer.class}, tree="[0]")
    private Output<Integer> maxPathLength;

    /**
     * @return Maximum number of intermediate certificates that may follow this certificate in a valid certification path. If `isCaCertificate` is `false`, this value is ignored.
     * 
     */
    public Output<Integer> maxPathLength() {
        return this.maxPathLength;
    }
    /**
     * Private key in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format, that the certificate will belong to.
     * 
     */
    @Export(name="privateKeyPem", refs={String.class}, tree="[0]")
    private Output<String> privateKeyPem;

    /**
     * @return Private key in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format, that the certificate will belong to.
     * 
     */
    public Output<String> privateKeyPem() {
        return this.privateKeyPem;
    }
    /**
     * Is the certificate either expired (i.e. beyond the `validityPeriodHours`) or ready for an early renewal (i.e. within the `earlyRenewalHours`)?
     * 
     */
    @Export(name="readyForRenewal", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> readyForRenewal;

    /**
     * @return Is the certificate either expired (i.e. beyond the `validityPeriodHours`) or ready for an early renewal (i.e. within the `earlyRenewalHours`)?
     * 
     */
    public Output<Boolean> readyForRenewal() {
        return this.readyForRenewal;
    }
    /**
     * Should the generated certificate include an [authority key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.1): for self-signed certificates this is the same value as the [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).
     * 
     */
    @Export(name="setAuthorityKeyId", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> setAuthorityKeyId;

    /**
     * @return Should the generated certificate include an [authority key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.1): for self-signed certificates this is the same value as the [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).
     * 
     */
    public Output<Boolean> setAuthorityKeyId() {
        return this.setAuthorityKeyId;
    }
    /**
     * Should the generated certificate include a [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).
     * 
     */
    @Export(name="setSubjectKeyId", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> setSubjectKeyId;

    /**
     * @return Should the generated certificate include a [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).
     * 
     */
    public Output<Boolean> setSubjectKeyId() {
        return this.setSubjectKeyId;
    }
    /**
     * The subject for which a certificate is being requested. The acceptable arguments are all optional and their naming is based upon [Issuer Distinguished Names (RFC5280)](https://tools.ietf.org/html/rfc5280#section-4.1.2.4) section.
     * 
     */
    @Export(name="subject", refs={SelfSignedCertSubject.class}, tree="[0]")
    private Output</* @Nullable */ SelfSignedCertSubject> subject;

    /**
     * @return The subject for which a certificate is being requested. The acceptable arguments are all optional and their naming is based upon [Issuer Distinguished Names (RFC5280)](https://tools.ietf.org/html/rfc5280#section-4.1.2.4) section.
     * 
     */
    public Output<Optional<SelfSignedCertSubject>> subject() {
        return Codegen.optional(this.subject);
    }
    /**
     * List of URIs for which a certificate is being requested (i.e. certificate subjects).
     * 
     */
    @Export(name="uris", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> uris;

    /**
     * @return List of URIs for which a certificate is being requested (i.e. certificate subjects).
     * 
     */
    public Output<Optional<List<String>>> uris() {
        return Codegen.optional(this.uris);
    }
    /**
     * The time until which the certificate is invalid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.
     * 
     */
    @Export(name="validityEndTime", refs={String.class}, tree="[0]")
    private Output<String> validityEndTime;

    /**
     * @return The time until which the certificate is invalid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.
     * 
     */
    public Output<String> validityEndTime() {
        return this.validityEndTime;
    }
    /**
     * Number of hours, after initial issuing, that the certificate will remain valid for.
     * 
     */
    @Export(name="validityPeriodHours", refs={Integer.class}, tree="[0]")
    private Output<Integer> validityPeriodHours;

    /**
     * @return Number of hours, after initial issuing, that the certificate will remain valid for.
     * 
     */
    public Output<Integer> validityPeriodHours() {
        return this.validityPeriodHours;
    }
    /**
     * The time after which the certificate is valid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.
     * 
     */
    @Export(name="validityStartTime", refs={String.class}, tree="[0]")
    private Output<String> validityStartTime;

    /**
     * @return The time after which the certificate is valid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.
     * 
     */
    public Output<String> validityStartTime() {
        return this.validityStartTime;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public SelfSignedCert(java.lang.String name) {
        this(name, SelfSignedCertArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public SelfSignedCert(java.lang.String name, SelfSignedCertArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public SelfSignedCert(java.lang.String name, SelfSignedCertArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("tls:index/selfSignedCert:SelfSignedCert", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private SelfSignedCert(java.lang.String name, Output<java.lang.String> id, @Nullable SelfSignedCertState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("tls:index/selfSignedCert:SelfSignedCert", name, state, makeResourceOptions(options, id), false);
    }

    private static SelfSignedCertArgs makeArgs(SelfSignedCertArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? SelfSignedCertArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "privateKeyPem"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static SelfSignedCert get(java.lang.String name, Output<java.lang.String> id, @Nullable SelfSignedCertState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new SelfSignedCert(name, id, state, options);
    }
}
