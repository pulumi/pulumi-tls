// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.tls;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.tls.LocallySignedCertArgs;
import com.pulumi.tls.Utilities;
import com.pulumi.tls.inputs.LocallySignedCertState;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import javax.annotation.Nullable;

/**
 * Creates a TLS certificate in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format using a Certificate Signing Request (CSR) and signs it with a provided (local) Certificate Authority (CA).
 * 
 * &gt; **Note** Locally-signed certificates are generally only trusted by client software when
 * setup to use the provided CA. They are normally used in development environments
 * or when deployed internally to an organization.
 * 
 * ## Example Usage
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.tls.LocallySignedCert;
 * import com.pulumi.tls.LocallySignedCertArgs;
 * import com.pulumi.std.StdFunctions;
 * import com.pulumi.std.inputs.FileArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new LocallySignedCert("example", LocallySignedCertArgs.builder()
 *             .certRequestPem(StdFunctions.file(FileArgs.builder()
 *                 .input("cert_request.pem")
 *                 .build()).result())
 *             .caPrivateKeyPem(StdFunctions.file(FileArgs.builder()
 *                 .input("ca_private_key.pem")
 *                 .build()).result())
 *             .caCertPem(StdFunctions.file(FileArgs.builder()
 *                 .input("ca_cert.pem")
 *                 .build()).result())
 *             .validityPeriodHours(12)
 *             .allowedUses(            
 *                 "key_encipherment",
 *                 "digital_signature",
 *                 "server_auth")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Automatic Renewal
 * 
 * This resource considers its instances to have been deleted after either their validity
 * periods ends (i.e. beyond the `validityPeriodHours`)
 * or the early renewal period is reached (i.e. within the `earlyRenewalHours`):
 * when this happens, the `readyForRenewal` attribute will be `true`.
 * At this time, applying the Terraform configuration will cause a new certificate to be
 * generated for the instance.
 * 
 * Therefore in a development environment with frequent deployments it may be convenient
 * to set a relatively-short expiration time and use early renewal to automatically provision
 * a new certificate when the current one is about to expire.
 * 
 * The creation of a new certificate may of course cause dependent resources to be updated
 * or replaced, depending on the lifecycle rules applying to those resources.
 * 
 */
@ResourceType(type="tls:index/locallySignedCert:LocallySignedCert")
public class LocallySignedCert extends com.pulumi.resources.CustomResource {
    /**
     * List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `anyExtended`, `certSigning`, `clientAuth`, `codeSigning`, `contentCommitment`, `crlSigning`, `dataEncipherment`, `decipherOnly`, `digitalSignature`, `emailProtection`, `encipherOnly`, `ipsecEndSystem`, `ipsecTunnel`, `ipsecUser`, `keyAgreement`, `keyEncipherment`, `microsoftCommercialCodeSigning`, `microsoftKernelCodeSigning`, `microsoftServerGatedCrypto`, `netscapeServerGatedCrypto`, `ocspSigning`, `serverAuth`, `timestamping`.
     * 
     */
    @Export(name="allowedUses", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> allowedUses;

    /**
     * @return List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `anyExtended`, `certSigning`, `clientAuth`, `codeSigning`, `contentCommitment`, `crlSigning`, `dataEncipherment`, `decipherOnly`, `digitalSignature`, `emailProtection`, `encipherOnly`, `ipsecEndSystem`, `ipsecTunnel`, `ipsecUser`, `keyAgreement`, `keyEncipherment`, `microsoftCommercialCodeSigning`, `microsoftKernelCodeSigning`, `microsoftServerGatedCrypto`, `netscapeServerGatedCrypto`, `ocspSigning`, `serverAuth`, `timestamping`.
     * 
     */
    public Output<List<String>> allowedUses() {
        return this.allowedUses;
    }
    /**
     * Certificate data of the Certificate Authority (CA) in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     * 
     */
    @Export(name="caCertPem", refs={String.class}, tree="[0]")
    private Output<String> caCertPem;

    /**
     * @return Certificate data of the Certificate Authority (CA) in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     * 
     */
    public Output<String> caCertPem() {
        return this.caCertPem;
    }
    /**
     * Name of the algorithm used when generating the private key provided in `caPrivateKeyPem`.
     * 
     */
    @Export(name="caKeyAlgorithm", refs={String.class}, tree="[0]")
    private Output<String> caKeyAlgorithm;

    /**
     * @return Name of the algorithm used when generating the private key provided in `caPrivateKeyPem`.
     * 
     */
    public Output<String> caKeyAlgorithm() {
        return this.caKeyAlgorithm;
    }
    /**
     * Private key of the Certificate Authority (CA) used to sign the certificate, in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     * 
     */
    @Export(name="caPrivateKeyPem", refs={String.class}, tree="[0]")
    private Output<String> caPrivateKeyPem;

    /**
     * @return Private key of the Certificate Authority (CA) used to sign the certificate, in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     * 
     */
    public Output<String> caPrivateKeyPem() {
        return this.caPrivateKeyPem;
    }
    /**
     * Certificate data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format. **NOTE**: the [underlying](https://pkg.go.dev/encoding/pem#Encode) [libraries](https://pkg.go.dev/golang.org/x/crypto/ssh#MarshalAuthorizedKey) that generate this value append a `\n` at the end of the PEM. In case this disrupts your use case, we recommend using `trimspace()`.
     * 
     */
    @Export(name="certPem", refs={String.class}, tree="[0]")
    private Output<String> certPem;

    /**
     * @return Certificate data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format. **NOTE**: the [underlying](https://pkg.go.dev/encoding/pem#Encode) [libraries](https://pkg.go.dev/golang.org/x/crypto/ssh#MarshalAuthorizedKey) that generate this value append a `\n` at the end of the PEM. In case this disrupts your use case, we recommend using `trimspace()`.
     * 
     */
    public Output<String> certPem() {
        return this.certPem;
    }
    /**
     * Certificate request data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     * 
     */
    @Export(name="certRequestPem", refs={String.class}, tree="[0]")
    private Output<String> certRequestPem;

    /**
     * @return Certificate request data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     * 
     */
    public Output<String> certRequestPem() {
        return this.certRequestPem;
    }
    /**
     * The resource will consider the certificate to have expired the given number of hours before its actual expiry time. This can be useful to deploy an updated certificate in advance of the expiration of the current certificate. However, the old certificate remains valid until its true expiration time, since this resource does not (and cannot) support certificate revocation. Also, this advance update can only be performed should the Terraform configuration be applied during the early renewal period. (default: `0`)
     * 
     */
    @Export(name="earlyRenewalHours", refs={Integer.class}, tree="[0]")
    private Output<Integer> earlyRenewalHours;

    /**
     * @return The resource will consider the certificate to have expired the given number of hours before its actual expiry time. This can be useful to deploy an updated certificate in advance of the expiration of the current certificate. However, the old certificate remains valid until its true expiration time, since this resource does not (and cannot) support certificate revocation. Also, this advance update can only be performed should the Terraform configuration be applied during the early renewal period. (default: `0`)
     * 
     */
    public Output<Integer> earlyRenewalHours() {
        return this.earlyRenewalHours;
    }
    /**
     * Is the generated certificate representing a Certificate Authority (CA) (default: `false`).
     * 
     */
    @Export(name="isCaCertificate", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> isCaCertificate;

    /**
     * @return Is the generated certificate representing a Certificate Authority (CA) (default: `false`).
     * 
     */
    public Output<Boolean> isCaCertificate() {
        return this.isCaCertificate;
    }
    /**
     * Maximum number of intermediate certificates that may follow this certificate in a valid certification path. If `isCaCertificate` is `false`, this value is ignored.
     * 
     */
    @Export(name="maxPathLength", refs={Integer.class}, tree="[0]")
    private Output<Integer> maxPathLength;

    /**
     * @return Maximum number of intermediate certificates that may follow this certificate in a valid certification path. If `isCaCertificate` is `false`, this value is ignored.
     * 
     */
    public Output<Integer> maxPathLength() {
        return this.maxPathLength;
    }
    /**
     * Is the certificate either expired (i.e. beyond the `validityPeriodHours`) or ready for an early renewal (i.e. within the `earlyRenewalHours`)?
     * 
     */
    @Export(name="readyForRenewal", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> readyForRenewal;

    /**
     * @return Is the certificate either expired (i.e. beyond the `validityPeriodHours`) or ready for an early renewal (i.e. within the `earlyRenewalHours`)?
     * 
     */
    public Output<Boolean> readyForRenewal() {
        return this.readyForRenewal;
    }
    /**
     * Should the generated certificate include a [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).
     * 
     */
    @Export(name="setSubjectKeyId", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> setSubjectKeyId;

    /**
     * @return Should the generated certificate include a [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).
     * 
     */
    public Output<Boolean> setSubjectKeyId() {
        return this.setSubjectKeyId;
    }
    /**
     * The time until which the certificate is invalid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.
     * 
     */
    @Export(name="validityEndTime", refs={String.class}, tree="[0]")
    private Output<String> validityEndTime;

    /**
     * @return The time until which the certificate is invalid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.
     * 
     */
    public Output<String> validityEndTime() {
        return this.validityEndTime;
    }
    /**
     * Number of hours, after initial issuing, that the certificate will remain valid for.
     * 
     */
    @Export(name="validityPeriodHours", refs={Integer.class}, tree="[0]")
    private Output<Integer> validityPeriodHours;

    /**
     * @return Number of hours, after initial issuing, that the certificate will remain valid for.
     * 
     */
    public Output<Integer> validityPeriodHours() {
        return this.validityPeriodHours;
    }
    /**
     * The time after which the certificate is valid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.
     * 
     */
    @Export(name="validityStartTime", refs={String.class}, tree="[0]")
    private Output<String> validityStartTime;

    /**
     * @return The time after which the certificate is valid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.
     * 
     */
    public Output<String> validityStartTime() {
        return this.validityStartTime;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public LocallySignedCert(java.lang.String name) {
        this(name, LocallySignedCertArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public LocallySignedCert(java.lang.String name, LocallySignedCertArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public LocallySignedCert(java.lang.String name, LocallySignedCertArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("tls:index/locallySignedCert:LocallySignedCert", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private LocallySignedCert(java.lang.String name, Output<java.lang.String> id, @Nullable LocallySignedCertState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("tls:index/locallySignedCert:LocallySignedCert", name, state, makeResourceOptions(options, id), false);
    }

    private static LocallySignedCertArgs makeArgs(LocallySignedCertArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? LocallySignedCertArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "caPrivateKeyPem"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static LocallySignedCert get(java.lang.String name, Output<java.lang.String> id, @Nullable LocallySignedCertState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new LocallySignedCert(name, id, state, options);
    }
}
