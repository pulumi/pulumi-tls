// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * Creates a TLS certificate in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format using a Certificate Signing Request (CSR) and signs it with a provided (local) Certificate Authority (CA).
 *
 * > **Note** Locally-signed certificates are generally only trusted by client software when
 * setup to use the provided CA. They are normally used in development environments
 * or when deployed internally to an organization.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as std from "@pulumi/std";
 * import * as tls from "@pulumi/tls";
 *
 * const example = new tls.LocallySignedCert("example", {
 *     certRequestPem: std.file({
 *         input: "cert_request.pem",
 *     }).then(invoke => invoke.result),
 *     caPrivateKeyPem: std.file({
 *         input: "ca_private_key.pem",
 *     }).then(invoke => invoke.result),
 *     caCertPem: std.file({
 *         input: "ca_cert.pem",
 *     }).then(invoke => invoke.result),
 *     validityPeriodHours: 12,
 *     allowedUses: [
 *         "key_encipherment",
 *         "digital_signature",
 *         "server_auth",
 *     ],
 * });
 * ```
 *
 * ## Automatic Renewal
 *
 * This resource considers its instances to have been deleted after either their validity
 * periods ends (i.e. beyond the `validityPeriodHours`)
 * or the early renewal period is reached (i.e. within the `earlyRenewalHours`):
 * when this happens, the `readyForRenewal` attribute will be `true`.
 * At this time, applying the Terraform configuration will cause a new certificate to be
 * generated for the instance.
 *
 * Therefore in a development environment with frequent deployments it may be convenient
 * to set a relatively-short expiration time and use early renewal to automatically provision
 * a new certificate when the current one is about to expire.
 *
 * The creation of a new certificate may of course cause dependent resources to be updated
 * or replaced, depending on the lifecycle rules applying to those resources.
 */
export class LocallySignedCert extends pulumi.CustomResource {
    /**
     * Get an existing LocallySignedCert resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: LocallySignedCertState, opts?: pulumi.CustomResourceOptions): LocallySignedCert {
        return new LocallySignedCert(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'tls:index/locallySignedCert:LocallySignedCert';

    /**
     * Returns true if the given object is an instance of LocallySignedCert.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is LocallySignedCert {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === LocallySignedCert.__pulumiType;
    }

    /**
     * List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `anyExtended`, `certSigning`, `clientAuth`, `codeSigning`, `contentCommitment`, `crlSigning`, `dataEncipherment`, `decipherOnly`, `digitalSignature`, `emailProtection`, `encipherOnly`, `ipsecEndSystem`, `ipsecTunnel`, `ipsecUser`, `keyAgreement`, `keyEncipherment`, `microsoftCommercialCodeSigning`, `microsoftKernelCodeSigning`, `microsoftServerGatedCrypto`, `netscapeServerGatedCrypto`, `ocspSigning`, `serverAuth`, `timestamping`.
     */
    declare public readonly allowedUses: pulumi.Output<string[]>;
    /**
     * Certificate data of the Certificate Authority (CA) in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     */
    declare public readonly caCertPem: pulumi.Output<string>;
    /**
     * Name of the algorithm used when generating the private key provided in `caPrivateKeyPem`.
     */
    declare public /*out*/ readonly caKeyAlgorithm: pulumi.Output<string>;
    /**
     * Private key of the Certificate Authority (CA) used to sign the certificate, in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     */
    declare public readonly caPrivateKeyPem: pulumi.Output<string>;
    /**
     * Certificate data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format. **NOTE**: the [underlying](https://pkg.go.dev/encoding/pem#Encode) [libraries](https://pkg.go.dev/golang.org/x/crypto/ssh#MarshalAuthorizedKey) that generate this value append a `\n` at the end of the PEM. In case this disrupts your use case, we recommend using `trimspace()`.
     */
    declare public /*out*/ readonly certPem: pulumi.Output<string>;
    /**
     * Certificate request data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     */
    declare public readonly certRequestPem: pulumi.Output<string>;
    /**
     * The resource will consider the certificate to have expired the given number of hours before its actual expiry time. This can be useful to deploy an updated certificate in advance of the expiration of the current certificate. However, the old certificate remains valid until its true expiration time, since this resource does not (and cannot) support certificate revocation. Also, this advance update can only be performed should the Terraform configuration be applied during the early renewal period. (default: `0`)
     */
    declare public readonly earlyRenewalHours: pulumi.Output<number>;
    /**
     * Is the generated certificate representing a Certificate Authority (CA) (default: `false`).
     */
    declare public readonly isCaCertificate: pulumi.Output<boolean>;
    /**
     * Maximum number of intermediate certificates that may follow this certificate in a valid certification path. If `isCaCertificate` is `false`, this value is ignored.
     */
    declare public readonly maxPathLength: pulumi.Output<number>;
    /**
     * Is the certificate either expired (i.e. beyond the `validityPeriodHours`) or ready for an early renewal (i.e. within the `earlyRenewalHours`)?
     */
    declare public /*out*/ readonly readyForRenewal: pulumi.Output<boolean>;
    /**
     * Should the generated certificate include a [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).
     */
    declare public readonly setSubjectKeyId: pulumi.Output<boolean>;
    /**
     * The time until which the certificate is invalid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.
     */
    declare public /*out*/ readonly validityEndTime: pulumi.Output<string>;
    /**
     * Number of hours, after initial issuing, that the certificate will remain valid for.
     */
    declare public readonly validityPeriodHours: pulumi.Output<number>;
    /**
     * The time after which the certificate is valid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.
     */
    declare public /*out*/ readonly validityStartTime: pulumi.Output<string>;

    /**
     * Create a LocallySignedCert resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: LocallySignedCertArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: LocallySignedCertArgs | LocallySignedCertState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as LocallySignedCertState | undefined;
            resourceInputs["allowedUses"] = state?.allowedUses;
            resourceInputs["caCertPem"] = state?.caCertPem;
            resourceInputs["caKeyAlgorithm"] = state?.caKeyAlgorithm;
            resourceInputs["caPrivateKeyPem"] = state?.caPrivateKeyPem;
            resourceInputs["certPem"] = state?.certPem;
            resourceInputs["certRequestPem"] = state?.certRequestPem;
            resourceInputs["earlyRenewalHours"] = state?.earlyRenewalHours;
            resourceInputs["isCaCertificate"] = state?.isCaCertificate;
            resourceInputs["maxPathLength"] = state?.maxPathLength;
            resourceInputs["readyForRenewal"] = state?.readyForRenewal;
            resourceInputs["setSubjectKeyId"] = state?.setSubjectKeyId;
            resourceInputs["validityEndTime"] = state?.validityEndTime;
            resourceInputs["validityPeriodHours"] = state?.validityPeriodHours;
            resourceInputs["validityStartTime"] = state?.validityStartTime;
        } else {
            const args = argsOrState as LocallySignedCertArgs | undefined;
            if (args?.allowedUses === undefined && !opts.urn) {
                throw new Error("Missing required property 'allowedUses'");
            }
            if (args?.caCertPem === undefined && !opts.urn) {
                throw new Error("Missing required property 'caCertPem'");
            }
            if (args?.caPrivateKeyPem === undefined && !opts.urn) {
                throw new Error("Missing required property 'caPrivateKeyPem'");
            }
            if (args?.certRequestPem === undefined && !opts.urn) {
                throw new Error("Missing required property 'certRequestPem'");
            }
            if (args?.validityPeriodHours === undefined && !opts.urn) {
                throw new Error("Missing required property 'validityPeriodHours'");
            }
            resourceInputs["allowedUses"] = args?.allowedUses;
            resourceInputs["caCertPem"] = args?.caCertPem;
            resourceInputs["caPrivateKeyPem"] = args?.caPrivateKeyPem ? pulumi.secret(args.caPrivateKeyPem) : undefined;
            resourceInputs["certRequestPem"] = args?.certRequestPem;
            resourceInputs["earlyRenewalHours"] = args?.earlyRenewalHours;
            resourceInputs["isCaCertificate"] = args?.isCaCertificate;
            resourceInputs["maxPathLength"] = args?.maxPathLength;
            resourceInputs["setSubjectKeyId"] = args?.setSubjectKeyId;
            resourceInputs["validityPeriodHours"] = args?.validityPeriodHours;
            resourceInputs["caKeyAlgorithm"] = undefined /*out*/;
            resourceInputs["certPem"] = undefined /*out*/;
            resourceInputs["readyForRenewal"] = undefined /*out*/;
            resourceInputs["validityEndTime"] = undefined /*out*/;
            resourceInputs["validityStartTime"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["caPrivateKeyPem"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(LocallySignedCert.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering LocallySignedCert resources.
 */
export interface LocallySignedCertState {
    /**
     * List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `anyExtended`, `certSigning`, `clientAuth`, `codeSigning`, `contentCommitment`, `crlSigning`, `dataEncipherment`, `decipherOnly`, `digitalSignature`, `emailProtection`, `encipherOnly`, `ipsecEndSystem`, `ipsecTunnel`, `ipsecUser`, `keyAgreement`, `keyEncipherment`, `microsoftCommercialCodeSigning`, `microsoftKernelCodeSigning`, `microsoftServerGatedCrypto`, `netscapeServerGatedCrypto`, `ocspSigning`, `serverAuth`, `timestamping`.
     */
    allowedUses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Certificate data of the Certificate Authority (CA) in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     */
    caCertPem?: pulumi.Input<string>;
    /**
     * Name of the algorithm used when generating the private key provided in `caPrivateKeyPem`.
     */
    caKeyAlgorithm?: pulumi.Input<string>;
    /**
     * Private key of the Certificate Authority (CA) used to sign the certificate, in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     */
    caPrivateKeyPem?: pulumi.Input<string>;
    /**
     * Certificate data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format. **NOTE**: the [underlying](https://pkg.go.dev/encoding/pem#Encode) [libraries](https://pkg.go.dev/golang.org/x/crypto/ssh#MarshalAuthorizedKey) that generate this value append a `\n` at the end of the PEM. In case this disrupts your use case, we recommend using `trimspace()`.
     */
    certPem?: pulumi.Input<string>;
    /**
     * Certificate request data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     */
    certRequestPem?: pulumi.Input<string>;
    /**
     * The resource will consider the certificate to have expired the given number of hours before its actual expiry time. This can be useful to deploy an updated certificate in advance of the expiration of the current certificate. However, the old certificate remains valid until its true expiration time, since this resource does not (and cannot) support certificate revocation. Also, this advance update can only be performed should the Terraform configuration be applied during the early renewal period. (default: `0`)
     */
    earlyRenewalHours?: pulumi.Input<number>;
    /**
     * Is the generated certificate representing a Certificate Authority (CA) (default: `false`).
     */
    isCaCertificate?: pulumi.Input<boolean>;
    /**
     * Maximum number of intermediate certificates that may follow this certificate in a valid certification path. If `isCaCertificate` is `false`, this value is ignored.
     */
    maxPathLength?: pulumi.Input<number>;
    /**
     * Is the certificate either expired (i.e. beyond the `validityPeriodHours`) or ready for an early renewal (i.e. within the `earlyRenewalHours`)?
     */
    readyForRenewal?: pulumi.Input<boolean>;
    /**
     * Should the generated certificate include a [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).
     */
    setSubjectKeyId?: pulumi.Input<boolean>;
    /**
     * The time until which the certificate is invalid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.
     */
    validityEndTime?: pulumi.Input<string>;
    /**
     * Number of hours, after initial issuing, that the certificate will remain valid for.
     */
    validityPeriodHours?: pulumi.Input<number>;
    /**
     * The time after which the certificate is valid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.
     */
    validityStartTime?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a LocallySignedCert resource.
 */
export interface LocallySignedCertArgs {
    /**
     * List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `anyExtended`, `certSigning`, `clientAuth`, `codeSigning`, `contentCommitment`, `crlSigning`, `dataEncipherment`, `decipherOnly`, `digitalSignature`, `emailProtection`, `encipherOnly`, `ipsecEndSystem`, `ipsecTunnel`, `ipsecUser`, `keyAgreement`, `keyEncipherment`, `microsoftCommercialCodeSigning`, `microsoftKernelCodeSigning`, `microsoftServerGatedCrypto`, `netscapeServerGatedCrypto`, `ocspSigning`, `serverAuth`, `timestamping`.
     */
    allowedUses: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Certificate data of the Certificate Authority (CA) in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     */
    caCertPem: pulumi.Input<string>;
    /**
     * Private key of the Certificate Authority (CA) used to sign the certificate, in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     */
    caPrivateKeyPem: pulumi.Input<string>;
    /**
     * Certificate request data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.
     */
    certRequestPem: pulumi.Input<string>;
    /**
     * The resource will consider the certificate to have expired the given number of hours before its actual expiry time. This can be useful to deploy an updated certificate in advance of the expiration of the current certificate. However, the old certificate remains valid until its true expiration time, since this resource does not (and cannot) support certificate revocation. Also, this advance update can only be performed should the Terraform configuration be applied during the early renewal period. (default: `0`)
     */
    earlyRenewalHours?: pulumi.Input<number>;
    /**
     * Is the generated certificate representing a Certificate Authority (CA) (default: `false`).
     */
    isCaCertificate?: pulumi.Input<boolean>;
    /**
     * Maximum number of intermediate certificates that may follow this certificate in a valid certification path. If `isCaCertificate` is `false`, this value is ignored.
     */
    maxPathLength?: pulumi.Input<number>;
    /**
     * Should the generated certificate include a [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).
     */
    setSubjectKeyId?: pulumi.Input<boolean>;
    /**
     * Number of hours, after initial issuing, that the certificate will remain valid for.
     */
    validityPeriodHours: pulumi.Input<number>;
}
