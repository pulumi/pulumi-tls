{
    "name": "tls",
    "description": "A Pulumi package to create TLS resources in Pulumi programs.",
    "keywords": [
        "pulumi",
        "tls"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`tls` Terraform Provider](https://github.com/hashicorp/terraform-provider-tls).",
    "repository": "https://github.com/pulumi/pulumi-tls",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "namespaces": {
                "tls": "Tls"
            },
            "compatibility": "tfbridge20"
        },
        "go": {
            "importBasePath": "github.com/pulumi/pulumi-tls/sdk/v5/go/tls",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package to create TLS resources in Pulumi programs.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-tls)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-tls` repo](https://github.com/pulumi/pulumi-tls/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-tls` repo](https://github.com/hashicorp/terraform-provider-tls/issues).",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true
        },
        "python": {
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            },
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-tls)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-tls` repo](https://github.com/pulumi/pulumi-tls/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-tls` repo](https://github.com/hashicorp/terraform-provider-tls/issues).",
            "compatibility": "tfbridge20",
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "proxy": {
                "$ref": "#/types/tls:config/proxy:proxy",
                "description": "Proxy used by resources and data sources that connect to external endpoints.\n"
            }
        }
    },
    "types": {
        "tls:config/proxy:proxy": {
            "properties": {
                "fromEnv": {
                    "type": "boolean",
                    "description": "When `true` the provider will discover the proxy configuration from environment variables. This is based upon [`http.ProxyFromEnvironment`](https://pkg.go.dev/net/http#ProxyFromEnvironment) and it supports the same environment variables (default: `true`).\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password used for Basic authentication against the Proxy.\n",
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "URL used to connect to the Proxy. Accepted schemes are: `http`, `https`, `socks5`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username (or Token) used for Basic authentication against the Proxy.\n"
                }
            },
            "type": "object"
        },
        "tls:index/CertRequestSubject:CertRequestSubject": {
            "properties": {
                "commonName": {
                    "type": "string",
                    "description": "Distinguished name: `CN`\n"
                },
                "country": {
                    "type": "string",
                    "description": "Distinguished name: `C`\n"
                },
                "locality": {
                    "type": "string",
                    "description": "Distinguished name: `L`\n"
                },
                "organization": {
                    "type": "string",
                    "description": "Distinguished name: `O`\n"
                },
                "organizationalUnit": {
                    "type": "string",
                    "description": "Distinguished name: `OU`\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "Distinguished name: `PC`\n"
                },
                "province": {
                    "type": "string",
                    "description": "Distinguished name: `ST`\n"
                },
                "serialNumber": {
                    "type": "string",
                    "description": "Distinguished name: `SERIALNUMBER`\n"
                },
                "streetAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Distinguished name: `STREET`\n"
                }
            },
            "type": "object"
        },
        "tls:index/ProviderProxy:ProviderProxy": {
            "properties": {
                "fromEnv": {
                    "type": "boolean",
                    "description": "When `true` the provider will discover the proxy configuration from environment variables. This is based upon [`http.ProxyFromEnvironment`](https://pkg.go.dev/net/http#ProxyFromEnvironment) and it supports the same environment variables (default: `true`).\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password used for Basic authentication against the Proxy.\n",
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "URL used to connect to the Proxy. Accepted schemes are: `http`, `https`, `socks5`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username (or Token) used for Basic authentication against the Proxy.\n"
                }
            },
            "type": "object"
        },
        "tls:index/SelfSignedCertSubject:SelfSignedCertSubject": {
            "properties": {
                "commonName": {
                    "type": "string",
                    "description": "Distinguished name: `CN`\n"
                },
                "country": {
                    "type": "string",
                    "description": "Distinguished name: `C`\n"
                },
                "locality": {
                    "type": "string",
                    "description": "Distinguished name: `L`\n"
                },
                "organization": {
                    "type": "string",
                    "description": "Distinguished name: `O`\n"
                },
                "organizationalUnit": {
                    "type": "string",
                    "description": "Distinguished name: `OU`\n"
                },
                "postalCode": {
                    "type": "string",
                    "description": "Distinguished name: `PC`\n"
                },
                "province": {
                    "type": "string",
                    "description": "Distinguished name: `ST`\n"
                },
                "serialNumber": {
                    "type": "string",
                    "description": "Distinguished name: `SERIALNUMBER`\n"
                },
                "streetAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Distinguished name: `STREET`\n"
                }
            },
            "type": "object"
        },
        "tls:index/getCertificateCertificate:getCertificateCertificate": {
            "properties": {
                "certPem": {
                    "type": "string",
                    "description": "Certificate data in PEM (RFC 1421).\n"
                },
                "isCa": {
                    "type": "boolean",
                    "description": "`true` if the certificate is of a CA (Certificate Authority).\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "Who verified and signed the certificate, roughly following [RFC2253](https://tools.ietf.org/html/rfc2253).\n"
                },
                "notAfter": {
                    "type": "string",
                    "description": "The time until which the certificate is invalid, as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                },
                "notBefore": {
                    "type": "string",
                    "description": "The time after which the certificate is valid, as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                },
                "publicKeyAlgorithm": {
                    "type": "string",
                    "description": "The key algorithm used to create the certificate.\n"
                },
                "serialNumber": {
                    "type": "string",
                    "description": "Number that uniquely identifies the certificate with the CA's system.\nThe `format` function can be used to convert this *base 10* number into other bases, such as hex.\n"
                },
                "sha1Fingerprint": {
                    "type": "string",
                    "description": "The SHA1 fingerprint of the public key of the certificate.\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "The algorithm used to sign the certificate.\n"
                },
                "subject": {
                    "type": "string",
                    "description": "The entity the certificate belongs to, roughly following [RFC2253](https://tools.ietf.org/html/rfc2253).\n"
                },
                "version": {
                    "type": "integer",
                    "description": "The version the certificate is in.\n"
                }
            },
            "type": "object",
            "required": [
                "certPem",
                "isCa",
                "issuer",
                "notAfter",
                "notBefore",
                "publicKeyAlgorithm",
                "serialNumber",
                "sha1Fingerprint",
                "signatureAlgorithm",
                "subject",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the tls package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "proxy": {
                "$ref": "#/types/tls:index/ProviderProxy:ProviderProxy",
                "description": "Proxy used by resources and data sources that connect to external endpoints.\n"
            }
        },
        "inputProperties": {
            "proxy": {
                "$ref": "#/types/tls:index/ProviderProxy:ProviderProxy",
                "description": "Proxy used by resources and data sources that connect to external endpoints.\n"
            }
        }
    },
    "resources": {
        "tls:index/certRequest:CertRequest": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as std from \"@pulumi/std\";\nimport * as tls from \"@pulumi/tls\";\n\nconst example = new tls.CertRequest(\"example\", {\n    privateKeyPem: std.file({\n        input: \"private_key.pem\",\n    }).then(invoke =\u003e invoke.result),\n    subject: {\n        commonName: \"example.com\",\n        organization: \"ACME Examples, Inc\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_std as std\nimport pulumi_tls as tls\n\nexample = tls.CertRequest(\"example\",\n    private_key_pem=std.file(input=\"private_key.pem\").result,\n    subject=tls.CertRequestSubjectArgs(\n        common_name=\"example.com\",\n        organization=\"ACME Examples, Inc\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Std = Pulumi.Std;\nusing Tls = Pulumi.Tls;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Tls.CertRequest(\"example\", new()\n    {\n        PrivateKeyPem = Std.File.Invoke(new()\n        {\n            Input = \"private_key.pem\",\n        }).Apply(invoke =\u003e invoke.Result),\n        Subject = new Tls.Inputs.CertRequestSubjectArgs\n        {\n            CommonName = \"example.com\",\n            Organization = \"ACME Examples, Inc\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi-tls/sdk/v5/go/tls\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinvokeFile, err := std.File(ctx, \u0026std.FileArgs{\n\t\t\tInput: \"private_key.pem\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = tls.NewCertRequest(ctx, \"example\", \u0026tls.CertRequestArgs{\n\t\t\tPrivateKeyPem: invokeFile.Result,\n\t\t\tSubject: \u0026tls.CertRequestSubjectArgs{\n\t\t\t\tCommonName:   pulumi.String(\"example.com\"),\n\t\t\t\tOrganization: pulumi.String(\"ACME Examples, Inc\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.tls.CertRequest;\nimport com.pulumi.tls.CertRequestArgs;\nimport com.pulumi.tls.inputs.CertRequestSubjectArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CertRequest(\"example\", CertRequestArgs.builder()        \n            .privateKeyPem(StdFunctions.file(FileArgs.builder()\n                .input(\"private_key.pem\")\n                .build()).result())\n            .subject(CertRequestSubjectArgs.builder()\n                .commonName(\"example.com\")\n                .organization(\"ACME Examples, Inc\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: tls:CertRequest\n    properties:\n      privateKeyPem:\n        fn::invoke:\n          Function: std:file\n          Arguments:\n            input: private_key.pem\n          Return: result\n      subject:\n        commonName: example.com\n        organization: ACME Examples, Inc\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "certRequestPem": {
                    "type": "string",
                    "description": "The certificate request data in PEM (RFC 1421).\n"
                },
                "dnsNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of DNS names for which a certificate is being requested (i.e. certificate subjects).\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses for which a certificate is being requested (i.e. certificate subjects).\n"
                },
                "keyAlgorithm": {
                    "type": "string",
                    "description": "Name of the algorithm used when generating the private key provided in `private_key_pem`.\n"
                },
                "privateKeyPem": {
                    "type": "string",
                    "description": "Private key in PEM (RFC 1421) interpolation function.\n",
                    "secret": true
                },
                "subject": {
                    "$ref": "#/types/tls:index/CertRequestSubject:CertRequestSubject",
                    "description": "The subject for which a certificate is being requested. The acceptable arguments are all optional and their naming is based upon [Issuer Distinguished Names (RFC5280)](https://tools.ietf.org/html/rfc5280#section-4.1.2.4) section.\n"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of URIs for which a certificate is being requested (i.e. certificate subjects).\n"
                }
            },
            "required": [
                "certRequestPem",
                "keyAlgorithm",
                "privateKeyPem"
            ],
            "inputProperties": {
                "dnsNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of DNS names for which a certificate is being requested (i.e. certificate subjects).\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses for which a certificate is being requested (i.e. certificate subjects).\n"
                },
                "privateKeyPem": {
                    "type": "string",
                    "description": "Private key in PEM (RFC 1421) interpolation function.\n",
                    "secret": true
                },
                "subject": {
                    "$ref": "#/types/tls:index/CertRequestSubject:CertRequestSubject",
                    "description": "The subject for which a certificate is being requested. The acceptable arguments are all optional and their naming is based upon [Issuer Distinguished Names (RFC5280)](https://tools.ietf.org/html/rfc5280#section-4.1.2.4) section.\n"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of URIs for which a certificate is being requested (i.e. certificate subjects).\n"
                }
            },
            "requiredInputs": [
                "privateKeyPem"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CertRequest resources.\n",
                "properties": {
                    "certRequestPem": {
                        "type": "string",
                        "description": "The certificate request data in PEM (RFC 1421).\n"
                    },
                    "dnsNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of DNS names for which a certificate is being requested (i.e. certificate subjects).\n"
                    },
                    "ipAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of IP addresses for which a certificate is being requested (i.e. certificate subjects).\n"
                    },
                    "keyAlgorithm": {
                        "type": "string",
                        "description": "Name of the algorithm used when generating the private key provided in `private_key_pem`.\n"
                    },
                    "privateKeyPem": {
                        "type": "string",
                        "description": "Private key in PEM (RFC 1421) interpolation function.\n",
                        "secret": true
                    },
                    "subject": {
                        "$ref": "#/types/tls:index/CertRequestSubject:CertRequestSubject",
                        "description": "The subject for which a certificate is being requested. The acceptable arguments are all optional and their naming is based upon [Issuer Distinguished Names (RFC5280)](https://tools.ietf.org/html/rfc5280#section-4.1.2.4) section.\n"
                    },
                    "uris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of URIs for which a certificate is being requested (i.e. certificate subjects).\n"
                    }
                },
                "type": "object"
            }
        },
        "tls:index/locallySignedCert:LocallySignedCert": {
            "properties": {
                "allowedUses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `any_extended`, `cert_signing`, `client_auth`, `code_signing`, `content_commitment`, `crl_signing`, `data_encipherment`, `decipher_only`, `digital_signature`, `email_protection`, `encipher_only`, `ipsec_end_system`, `ipsec_tunnel`, `ipsec_user`, `key_agreement`, `key_encipherment`, `microsoft_commercial_code_signing`, `microsoft_kernel_code_signing`, `microsoft_server_gated_crypto`, `netscape_server_gated_crypto`, `ocsp_signing`, `server_auth`, `timestamping`.\n"
                },
                "caCertPem": {
                    "type": "string",
                    "description": "Certificate data of the Certificate Authority (CA) in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.\n"
                },
                "caKeyAlgorithm": {
                    "type": "string",
                    "description": "Name of the algorithm used when generating the private key provided in `ca_private_key_pem`.\n"
                },
                "caPrivateKeyPem": {
                    "type": "string",
                    "description": "Private key of the Certificate Authority (CA) used to sign the certificate, in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.\n",
                    "secret": true
                },
                "certPem": {
                    "type": "string",
                    "description": "Certificate data in PEM (RFC 1421).\n"
                },
                "certRequestPem": {
                    "type": "string",
                    "description": "Certificate request data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.\n"
                },
                "earlyRenewalHours": {
                    "type": "integer",
                    "description": "The resource will consider the certificate to have expired the given number of hours before its actual expiry time. This\ncan be useful to deploy an updated certificate in advance of the expiration of the current certificate. However, the old\ncertificate remains valid until its true expiration time, since this resource does not (and cannot) support certificate\nrevocation. Also, this advance update can only be performed should the Terraform configuration be applied during the\nearly renewal period. (default: `0`)\n"
                },
                "isCaCertificate": {
                    "type": "boolean",
                    "description": "Is the generated certificate representing a Certificate Authority (CA) (default: `false`).\n"
                },
                "readyForRenewal": {
                    "type": "boolean",
                    "description": "Is the certificate either expired (i.e. beyond the `validity_period_hours`) or ready for an early renewal (i.e. within the `early_renewal_hours`)?\n"
                },
                "setSubjectKeyId": {
                    "type": "boolean",
                    "description": "Should the generated certificate include a [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).\n"
                },
                "validityEndTime": {
                    "type": "string",
                    "description": "The time until which the certificate is invalid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                },
                "validityPeriodHours": {
                    "type": "integer",
                    "description": "Number of hours, after initial issuing, that the certificate will remain valid for.\n"
                },
                "validityStartTime": {
                    "type": "string",
                    "description": "The time after which the certificate is valid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                }
            },
            "required": [
                "allowedUses",
                "caCertPem",
                "caKeyAlgorithm",
                "caPrivateKeyPem",
                "certPem",
                "certRequestPem",
                "earlyRenewalHours",
                "isCaCertificate",
                "readyForRenewal",
                "setSubjectKeyId",
                "validityEndTime",
                "validityPeriodHours",
                "validityStartTime"
            ],
            "inputProperties": {
                "allowedUses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `any_extended`, `cert_signing`, `client_auth`, `code_signing`, `content_commitment`, `crl_signing`, `data_encipherment`, `decipher_only`, `digital_signature`, `email_protection`, `encipher_only`, `ipsec_end_system`, `ipsec_tunnel`, `ipsec_user`, `key_agreement`, `key_encipherment`, `microsoft_commercial_code_signing`, `microsoft_kernel_code_signing`, `microsoft_server_gated_crypto`, `netscape_server_gated_crypto`, `ocsp_signing`, `server_auth`, `timestamping`.\n"
                },
                "caCertPem": {
                    "type": "string",
                    "description": "Certificate data of the Certificate Authority (CA) in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.\n"
                },
                "caPrivateKeyPem": {
                    "type": "string",
                    "description": "Private key of the Certificate Authority (CA) used to sign the certificate, in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.\n",
                    "secret": true
                },
                "certRequestPem": {
                    "type": "string",
                    "description": "Certificate request data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.\n"
                },
                "earlyRenewalHours": {
                    "type": "integer",
                    "description": "The resource will consider the certificate to have expired the given number of hours before its actual expiry time. This\ncan be useful to deploy an updated certificate in advance of the expiration of the current certificate. However, the old\ncertificate remains valid until its true expiration time, since this resource does not (and cannot) support certificate\nrevocation. Also, this advance update can only be performed should the Terraform configuration be applied during the\nearly renewal period. (default: `0`)\n"
                },
                "isCaCertificate": {
                    "type": "boolean",
                    "description": "Is the generated certificate representing a Certificate Authority (CA) (default: `false`).\n"
                },
                "setSubjectKeyId": {
                    "type": "boolean",
                    "description": "Should the generated certificate include a [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).\n"
                },
                "validityPeriodHours": {
                    "type": "integer",
                    "description": "Number of hours, after initial issuing, that the certificate will remain valid for.\n"
                }
            },
            "requiredInputs": [
                "allowedUses",
                "caCertPem",
                "caPrivateKeyPem",
                "certRequestPem",
                "validityPeriodHours"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LocallySignedCert resources.\n",
                "properties": {
                    "allowedUses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `any_extended`, `cert_signing`, `client_auth`, `code_signing`, `content_commitment`, `crl_signing`, `data_encipherment`, `decipher_only`, `digital_signature`, `email_protection`, `encipher_only`, `ipsec_end_system`, `ipsec_tunnel`, `ipsec_user`, `key_agreement`, `key_encipherment`, `microsoft_commercial_code_signing`, `microsoft_kernel_code_signing`, `microsoft_server_gated_crypto`, `netscape_server_gated_crypto`, `ocsp_signing`, `server_auth`, `timestamping`.\n"
                    },
                    "caCertPem": {
                        "type": "string",
                        "description": "Certificate data of the Certificate Authority (CA) in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.\n"
                    },
                    "caKeyAlgorithm": {
                        "type": "string",
                        "description": "Name of the algorithm used when generating the private key provided in `ca_private_key_pem`.\n"
                    },
                    "caPrivateKeyPem": {
                        "type": "string",
                        "description": "Private key of the Certificate Authority (CA) used to sign the certificate, in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.\n",
                        "secret": true
                    },
                    "certPem": {
                        "type": "string",
                        "description": "Certificate data in PEM (RFC 1421).\n"
                    },
                    "certRequestPem": {
                        "type": "string",
                        "description": "Certificate request data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.\n"
                    },
                    "earlyRenewalHours": {
                        "type": "integer",
                        "description": "The resource will consider the certificate to have expired the given number of hours before its actual expiry time. This\ncan be useful to deploy an updated certificate in advance of the expiration of the current certificate. However, the old\ncertificate remains valid until its true expiration time, since this resource does not (and cannot) support certificate\nrevocation. Also, this advance update can only be performed should the Terraform configuration be applied during the\nearly renewal period. (default: `0`)\n"
                    },
                    "isCaCertificate": {
                        "type": "boolean",
                        "description": "Is the generated certificate representing a Certificate Authority (CA) (default: `false`).\n"
                    },
                    "readyForRenewal": {
                        "type": "boolean",
                        "description": "Is the certificate either expired (i.e. beyond the `validity_period_hours`) or ready for an early renewal (i.e. within the `early_renewal_hours`)?\n"
                    },
                    "setSubjectKeyId": {
                        "type": "boolean",
                        "description": "Should the generated certificate include a [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).\n"
                    },
                    "validityEndTime": {
                        "type": "string",
                        "description": "The time until which the certificate is invalid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                    },
                    "validityPeriodHours": {
                        "type": "integer",
                        "description": "Number of hours, after initial issuing, that the certificate will remain valid for.\n"
                    },
                    "validityStartTime": {
                        "type": "string",
                        "description": "The time after which the certificate is valid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                    }
                },
                "type": "object"
            }
        },
        "tls:index/privateKey:PrivateKey": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Name of the algorithm to use when generating the private key. Currently-supported values are: `RSA`, `ECDSA`, `ED25519`.\n"
                },
                "ecdsaCurve": {
                    "type": "string",
                    "description": "When `algorithm` is `ECDSA`, the name of the elliptic curve to use. Currently-supported values are: `P224`, `P256`, `P384`, `P521`. (default: `P224`).\n"
                },
                "privateKeyOpenssh": {
                    "type": "string",
                    "description": "Private key data in [OpenSSH PEM (RFC 4716)](https://datatracker.ietf.org/doc/html/rfc4716) format.\n",
                    "secret": true
                },
                "privateKeyPem": {
                    "type": "string",
                    "description": "Private key data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.\n",
                    "secret": true
                },
                "privateKeyPemPkcs8": {
                    "type": "string",
                    "description": "Private key data in [PKCS#8 PEM (RFC 5208)](https://datatracker.ietf.org/doc/html/rfc5208) format.\n",
                    "secret": true
                },
                "publicKeyFingerprintMd5": {
                    "type": "string",
                    "description": "The fingerprint of the public key data in OpenSSH MD5 hash format, e.g. `aa:bb:cc:...`. Only available if the selected private key format is compatible, similarly to `public_key_openssh` and the ECDSA P224 limitations.\n"
                },
                "publicKeyFingerprintSha256": {
                    "type": "string",
                    "description": "The fingerprint of the public key data in OpenSSH SHA256 hash format, e.g. `SHA256:...`. Only available if the selected private key format is compatible, similarly to `public_key_openssh` and the ECDSA P224 limitations.\n"
                },
                "publicKeyOpenssh": {
                    "type": "string",
                    "description": "The public key data in \"Authorized Keys\".\n"
                },
                "publicKeyPem": {
                    "type": "string",
                    "description": "Public key data in PEM (RFC 1421).\n"
                },
                "rsaBits": {
                    "type": "integer",
                    "description": "When `algorithm` is `RSA`, the size of the generated RSA key, in bits (default: `2048`).\n"
                }
            },
            "required": [
                "algorithm",
                "ecdsaCurve",
                "privateKeyOpenssh",
                "privateKeyPem",
                "privateKeyPemPkcs8",
                "publicKeyFingerprintMd5",
                "publicKeyFingerprintSha256",
                "publicKeyOpenssh",
                "publicKeyPem",
                "rsaBits"
            ],
            "inputProperties": {
                "algorithm": {
                    "type": "string",
                    "description": "Name of the algorithm to use when generating the private key. Currently-supported values are: `RSA`, `ECDSA`, `ED25519`.\n"
                },
                "ecdsaCurve": {
                    "type": "string",
                    "description": "When `algorithm` is `ECDSA`, the name of the elliptic curve to use. Currently-supported values are: `P224`, `P256`, `P384`, `P521`. (default: `P224`).\n"
                },
                "rsaBits": {
                    "type": "integer",
                    "description": "When `algorithm` is `RSA`, the size of the generated RSA key, in bits (default: `2048`).\n"
                }
            },
            "requiredInputs": [
                "algorithm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivateKey resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Name of the algorithm to use when generating the private key. Currently-supported values are: `RSA`, `ECDSA`, `ED25519`.\n"
                    },
                    "ecdsaCurve": {
                        "type": "string",
                        "description": "When `algorithm` is `ECDSA`, the name of the elliptic curve to use. Currently-supported values are: `P224`, `P256`, `P384`, `P521`. (default: `P224`).\n"
                    },
                    "privateKeyOpenssh": {
                        "type": "string",
                        "description": "Private key data in [OpenSSH PEM (RFC 4716)](https://datatracker.ietf.org/doc/html/rfc4716) format.\n",
                        "secret": true
                    },
                    "privateKeyPem": {
                        "type": "string",
                        "description": "Private key data in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format.\n",
                        "secret": true
                    },
                    "privateKeyPemPkcs8": {
                        "type": "string",
                        "description": "Private key data in [PKCS#8 PEM (RFC 5208)](https://datatracker.ietf.org/doc/html/rfc5208) format.\n",
                        "secret": true
                    },
                    "publicKeyFingerprintMd5": {
                        "type": "string",
                        "description": "The fingerprint of the public key data in OpenSSH MD5 hash format, e.g. `aa:bb:cc:...`. Only available if the selected private key format is compatible, similarly to `public_key_openssh` and the ECDSA P224 limitations.\n"
                    },
                    "publicKeyFingerprintSha256": {
                        "type": "string",
                        "description": "The fingerprint of the public key data in OpenSSH SHA256 hash format, e.g. `SHA256:...`. Only available if the selected private key format is compatible, similarly to `public_key_openssh` and the ECDSA P224 limitations.\n"
                    },
                    "publicKeyOpenssh": {
                        "type": "string",
                        "description": "The public key data in \"Authorized Keys\".\n"
                    },
                    "publicKeyPem": {
                        "type": "string",
                        "description": "Public key data in PEM (RFC 1421).\n"
                    },
                    "rsaBits": {
                        "type": "integer",
                        "description": "When `algorithm` is `RSA`, the size of the generated RSA key, in bits (default: `2048`).\n"
                    }
                },
                "type": "object"
            }
        },
        "tls:index/selfSignedCert:SelfSignedCert": {
            "properties": {
                "allowedUses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `any_extended`, `cert_signing`, `client_auth`, `code_signing`, `content_commitment`, `crl_signing`, `data_encipherment`, `decipher_only`, `digital_signature`, `email_protection`, `encipher_only`, `ipsec_end_system`, `ipsec_tunnel`, `ipsec_user`, `key_agreement`, `key_encipherment`, `microsoft_commercial_code_signing`, `microsoft_kernel_code_signing`, `microsoft_server_gated_crypto`, `netscape_server_gated_crypto`, `ocsp_signing`, `server_auth`, `timestamping`.\n"
                },
                "certPem": {
                    "type": "string",
                    "description": "Certificate data in PEM (RFC 1421).\n"
                },
                "dnsNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of DNS names for which a certificate is being requested (i.e. certificate subjects).\n"
                },
                "earlyRenewalHours": {
                    "type": "integer",
                    "description": "The resource will consider the certificate to have expired the given number of hours before its actual expiry time. This\ncan be useful to deploy an updated certificate in advance of the expiration of the current certificate. However, the old\ncertificate remains valid until its true expiration time, since this resource does not (and cannot) support certificate\nrevocation. Also, this advance update can only be performed should the Terraform configuration be applied during the\nearly renewal period. (default: `0`)\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses for which a certificate is being requested (i.e. certificate subjects).\n"
                },
                "isCaCertificate": {
                    "type": "boolean",
                    "description": "Is the generated certificate representing a Certificate Authority (CA) (default: `false`).\n"
                },
                "keyAlgorithm": {
                    "type": "string",
                    "description": "Name of the algorithm used when generating the private key provided in `private_key_pem`.\n"
                },
                "privateKeyPem": {
                    "type": "string",
                    "description": "Private key in PEM (RFC 1421) interpolation function.\n",
                    "secret": true
                },
                "readyForRenewal": {
                    "type": "boolean",
                    "description": "Is the certificate either expired (i.e. beyond the `validity_period_hours`) or ready for an early renewal (i.e. within the `early_renewal_hours`)?\n"
                },
                "setAuthorityKeyId": {
                    "type": "boolean",
                    "description": "Should the generated certificate include an [authority key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.1): for self-signed certificates this is the same value as the [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).\n"
                },
                "setSubjectKeyId": {
                    "type": "boolean",
                    "description": "Should the generated certificate include a [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).\n"
                },
                "subject": {
                    "$ref": "#/types/tls:index/SelfSignedCertSubject:SelfSignedCertSubject",
                    "description": "The subject for which a certificate is being requested. The acceptable arguments are all optional and their naming is based upon [Issuer Distinguished Names (RFC5280)](https://tools.ietf.org/html/rfc5280#section-4.1.2.4) section.\n"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of URIs for which a certificate is being requested (i.e. certificate subjects).\n"
                },
                "validityEndTime": {
                    "type": "string",
                    "description": "The time until which the certificate is invalid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                },
                "validityPeriodHours": {
                    "type": "integer",
                    "description": "Number of hours, after initial issuing, that the certificate will remain valid for.\n"
                },
                "validityStartTime": {
                    "type": "string",
                    "description": "The time after which the certificate is valid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                }
            },
            "required": [
                "allowedUses",
                "certPem",
                "earlyRenewalHours",
                "isCaCertificate",
                "keyAlgorithm",
                "privateKeyPem",
                "readyForRenewal",
                "setAuthorityKeyId",
                "setSubjectKeyId",
                "validityEndTime",
                "validityPeriodHours",
                "validityStartTime"
            ],
            "inputProperties": {
                "allowedUses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `any_extended`, `cert_signing`, `client_auth`, `code_signing`, `content_commitment`, `crl_signing`, `data_encipherment`, `decipher_only`, `digital_signature`, `email_protection`, `encipher_only`, `ipsec_end_system`, `ipsec_tunnel`, `ipsec_user`, `key_agreement`, `key_encipherment`, `microsoft_commercial_code_signing`, `microsoft_kernel_code_signing`, `microsoft_server_gated_crypto`, `netscape_server_gated_crypto`, `ocsp_signing`, `server_auth`, `timestamping`.\n"
                },
                "dnsNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of DNS names for which a certificate is being requested (i.e. certificate subjects).\n"
                },
                "earlyRenewalHours": {
                    "type": "integer",
                    "description": "The resource will consider the certificate to have expired the given number of hours before its actual expiry time. This\ncan be useful to deploy an updated certificate in advance of the expiration of the current certificate. However, the old\ncertificate remains valid until its true expiration time, since this resource does not (and cannot) support certificate\nrevocation. Also, this advance update can only be performed should the Terraform configuration be applied during the\nearly renewal period. (default: `0`)\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses for which a certificate is being requested (i.e. certificate subjects).\n"
                },
                "isCaCertificate": {
                    "type": "boolean",
                    "description": "Is the generated certificate representing a Certificate Authority (CA) (default: `false`).\n"
                },
                "privateKeyPem": {
                    "type": "string",
                    "description": "Private key in PEM (RFC 1421) interpolation function.\n",
                    "secret": true
                },
                "setAuthorityKeyId": {
                    "type": "boolean",
                    "description": "Should the generated certificate include an [authority key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.1): for self-signed certificates this is the same value as the [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).\n"
                },
                "setSubjectKeyId": {
                    "type": "boolean",
                    "description": "Should the generated certificate include a [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).\n"
                },
                "subject": {
                    "$ref": "#/types/tls:index/SelfSignedCertSubject:SelfSignedCertSubject",
                    "description": "The subject for which a certificate is being requested. The acceptable arguments are all optional and their naming is based upon [Issuer Distinguished Names (RFC5280)](https://tools.ietf.org/html/rfc5280#section-4.1.2.4) section.\n"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of URIs for which a certificate is being requested (i.e. certificate subjects).\n"
                },
                "validityPeriodHours": {
                    "type": "integer",
                    "description": "Number of hours, after initial issuing, that the certificate will remain valid for.\n"
                }
            },
            "requiredInputs": [
                "allowedUses",
                "privateKeyPem",
                "validityPeriodHours"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SelfSignedCert resources.\n",
                "properties": {
                    "allowedUses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `any_extended`, `cert_signing`, `client_auth`, `code_signing`, `content_commitment`, `crl_signing`, `data_encipherment`, `decipher_only`, `digital_signature`, `email_protection`, `encipher_only`, `ipsec_end_system`, `ipsec_tunnel`, `ipsec_user`, `key_agreement`, `key_encipherment`, `microsoft_commercial_code_signing`, `microsoft_kernel_code_signing`, `microsoft_server_gated_crypto`, `netscape_server_gated_crypto`, `ocsp_signing`, `server_auth`, `timestamping`.\n"
                    },
                    "certPem": {
                        "type": "string",
                        "description": "Certificate data in PEM (RFC 1421).\n"
                    },
                    "dnsNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of DNS names for which a certificate is being requested (i.e. certificate subjects).\n"
                    },
                    "earlyRenewalHours": {
                        "type": "integer",
                        "description": "The resource will consider the certificate to have expired the given number of hours before its actual expiry time. This\ncan be useful to deploy an updated certificate in advance of the expiration of the current certificate. However, the old\ncertificate remains valid until its true expiration time, since this resource does not (and cannot) support certificate\nrevocation. Also, this advance update can only be performed should the Terraform configuration be applied during the\nearly renewal period. (default: `0`)\n"
                    },
                    "ipAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of IP addresses for which a certificate is being requested (i.e. certificate subjects).\n"
                    },
                    "isCaCertificate": {
                        "type": "boolean",
                        "description": "Is the generated certificate representing a Certificate Authority (CA) (default: `false`).\n"
                    },
                    "keyAlgorithm": {
                        "type": "string",
                        "description": "Name of the algorithm used when generating the private key provided in `private_key_pem`.\n"
                    },
                    "privateKeyPem": {
                        "type": "string",
                        "description": "Private key in PEM (RFC 1421) interpolation function.\n",
                        "secret": true
                    },
                    "readyForRenewal": {
                        "type": "boolean",
                        "description": "Is the certificate either expired (i.e. beyond the `validity_period_hours`) or ready for an early renewal (i.e. within the `early_renewal_hours`)?\n"
                    },
                    "setAuthorityKeyId": {
                        "type": "boolean",
                        "description": "Should the generated certificate include an [authority key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.1): for self-signed certificates this is the same value as the [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).\n"
                    },
                    "setSubjectKeyId": {
                        "type": "boolean",
                        "description": "Should the generated certificate include a [subject key identifier](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.2) (default: `false`).\n"
                    },
                    "subject": {
                        "$ref": "#/types/tls:index/SelfSignedCertSubject:SelfSignedCertSubject",
                        "description": "The subject for which a certificate is being requested. The acceptable arguments are all optional and their naming is based upon [Issuer Distinguished Names (RFC5280)](https://tools.ietf.org/html/rfc5280#section-4.1.2.4) section.\n"
                    },
                    "uris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of URIs for which a certificate is being requested (i.e. certificate subjects).\n"
                    },
                    "validityEndTime": {
                        "type": "string",
                        "description": "The time until which the certificate is invalid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                    },
                    "validityPeriodHours": {
                        "type": "integer",
                        "description": "Number of hours, after initial issuing, that the certificate will remain valid for.\n"
                    },
                    "validityStartTime": {
                        "type": "string",
                        "description": "The time after which the certificate is valid, expressed as an [RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "tls:index/getCertificate:getCertificate": {
            "inputs": {
                "description": "A collection of arguments for invoking getCertificate.\n",
                "properties": {
                    "content": {
                        "type": "string",
                        "description": "The content of the certificate in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format. Cannot be used with `url`.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL of the website to get the certificates from. Cannot be used with `content`.\n"
                    },
                    "verifyChain": {
                        "type": "boolean",
                        "description": "Whether to verify the certificate chain while parsing it or not (default: `true`). Cannot be used with `content`.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCertificate.\n",
                "properties": {
                    "certificates": {
                        "description": "The certificates protecting the site, with the root of the chain first.\n",
                        "items": {
                            "$ref": "#/types/tls:index/getCertificateCertificate:getCertificateCertificate"
                        },
                        "type": "array"
                    },
                    "content": {
                        "description": "The content of the certificate in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format. Cannot be used with `url`.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "Unique identifier of this data source: hashing of the certificates in the chain.\n",
                        "type": "string"
                    },
                    "url": {
                        "description": "The URL of the website to get the certificates from. Cannot be used with `content`.\n",
                        "type": "string"
                    },
                    "verifyChain": {
                        "description": "Whether to verify the certificate chain while parsing it or not (default: `true`). Cannot be used with `content`.\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "certificates",
                    "id"
                ],
                "type": "object"
            }
        },
        "tls:index/getPublicKey:getPublicKey": {
            "description": "Get a public key from a PEM-encoded private key.\n\nUse this data source to get the public key from a [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) or [OpenSSH PEM (RFC 4716)](https://datatracker.ietf.org/doc/html/rfc4716) formatted private key, for use in other resources.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as std from \"@pulumi/std\";\nimport * as tls from \"@pulumi/tls\";\n\nconst ed25519_example = new tls.PrivateKey(\"ed25519-example\", {algorithm: \"ED25519\"});\n// Public key loaded from a terraform-generated private key, using the PEM (RFC 1421) format\nconst privateKeyPem-example = tls.getPublicKeyOutput({\n    privateKeyPem: ed25519_example.privateKeyPem,\n});\n// Public key loaded from filesystem, using the Open SSH (RFC 4716) format\nconst privateKeyOpenssh-example = std.file({\n    input: \"~/.ssh/id_rsa_rfc4716\",\n}).then(invoke =\u003e tls.getPublicKey({\n    privateKeyOpenssh: invoke.result,\n}));\n```\n```python\nimport pulumi\nimport pulumi_std as std\nimport pulumi_tls as tls\n\ned25519_example = tls.PrivateKey(\"ed25519-example\", algorithm=\"ED25519\")\n# Public key loaded from a terraform-generated private key, using the PEM (RFC 1421) format\nprivate_key_pem_example = tls.get_public_key_output(private_key_pem=ed25519_example.private_key_pem)\n# Public key loaded from filesystem, using the Open SSH (RFC 4716) format\nprivate_key_openssh_example = tls.get_public_key(private_key_openssh=std.file(input=\"~/.ssh/id_rsa_rfc4716\").result)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Std = Pulumi.Std;\nusing Tls = Pulumi.Tls;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ed25519_example = new Tls.PrivateKey(\"ed25519-example\", new()\n    {\n        Algorithm = \"ED25519\",\n    });\n\n    // Public key loaded from a terraform-generated private key, using the PEM (RFC 1421) format\n    var privateKeyPem_example = Tls.GetPublicKey.Invoke(new()\n    {\n        PrivateKeyPem = ed25519_example.PrivateKeyPem,\n    });\n\n    // Public key loaded from filesystem, using the Open SSH (RFC 4716) format\n    var privateKeyOpenssh_example = Tls.GetPublicKey.Invoke(new()\n    {\n        PrivateKeyOpenssh = Std.File.Invoke(new()\n        {\n            Input = \"~/.ssh/id_rsa_rfc4716\",\n        }).Result,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi-tls/sdk/v5/go/tls\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\nfunc main() {\npulumi.Run(func(ctx *pulumi.Context) error {\n_, err := tls.NewPrivateKey(ctx, \"ed25519-example\", \u0026tls.PrivateKeyArgs{\nAlgorithm: pulumi.String(\"ED25519\"),\n})\nif err != nil {\nreturn err\n}\n// Public key loaded from a terraform-generated private key, using the PEM (RFC 1421) format\n_ = tls.GetPublicKeyOutput(ctx, tls.GetPublicKeyOutputArgs{\nPrivateKeyPem: ed25519_example.PrivateKeyPem,\n}, nil);\n// Public key loaded from filesystem, using the Open SSH (RFC 4716) format\n_, err = tls.GetPublicKey(ctx, invokeFile, err := std.File(ctx, \u0026std.FileArgs{\nInput: \"~/.ssh/id_rsa_rfc4716\",\n}, nil)\nif err != nil {\nreturn err\n}\n\u0026tls.GetPublicKeyArgs{\nPrivateKeyOpenssh: pulumi.StringRef(invokeFile.Result),\n}, nil);\nif err != nil {\nreturn err\n}\nreturn nil\n})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.tls.PrivateKey;\nimport com.pulumi.tls.PrivateKeyArgs;\nimport com.pulumi.tls.TlsFunctions;\nimport com.pulumi.tls.inputs.GetPublicKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ed25519_example = new PrivateKey(\"ed25519-example\", PrivateKeyArgs.builder()        \n            .algorithm(\"ED25519\")\n            .build());\n\n        // Public key loaded from a terraform-generated private key, using the PEM (RFC 1421) format\n        final var privateKeyPem-example = TlsFunctions.getPublicKey(GetPublicKeyArgs.builder()\n            .privateKeyPem(ed25519_example.privateKeyPem())\n            .build());\n\n        // Public key loaded from filesystem, using the Open SSH (RFC 4716) format\n        final var privateKeyOpenssh-example = TlsFunctions.getPublicKey(GetPublicKeyArgs.builder()\n            .privateKeyOpenssh(StdFunctions.file(FileArgs.builder()\n                .input(\"~/.ssh/id_rsa_rfc4716\")\n                .build()).result())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ed25519-example:\n    type: tls:PrivateKey\n    properties:\n      algorithm: ED25519\nvariables:\n  # Public key loaded from a terraform-generated private key, using the PEM (RFC 1421) format\n  privateKeyPem-example:\n    fn::invoke:\n      Function: tls:getPublicKey\n      Arguments:\n        privateKeyPem: ${[\"ed25519-example\"].privateKeyPem}\n  # Public key loaded from filesystem, using the Open SSH (RFC 4716) format\n  privateKeyOpenssh-example:\n    fn::invoke:\n      Function: tls:getPublicKey\n      Arguments:\n        privateKeyOpenssh:\n          fn::invoke:\n            Function: std:file\n            Arguments:\n              input: ~/.ssh/id_rsa_rfc4716\n            Return: result\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPublicKey.\n",
                "properties": {
                    "privateKeyOpenssh": {
                        "type": "string",
                        "description": "The private key (in  [OpenSSH PEM (RFC 4716)](https://datatracker.ietf.org/doc/html/rfc4716) format) to extract the public key from. This is *mutually exclusive* with `private_key_pem`. Currently-supported algorithms for keys are: `RSA`, `ECDSA`, `ED25519`.\n",
                        "secret": true
                    },
                    "privateKeyPem": {
                        "type": "string",
                        "description": "The private key (in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format) to extract the public key from. This is *mutually exclusive* with `private_key_openssh`. Currently-supported algorithms for keys are: `RSA`, `ECDSA`, `ED25519`.\n",
                        "secret": true
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getPublicKey.\n",
                "properties": {
                    "algorithm": {
                        "description": "The name of the algorithm used by the given private key. Possible values are: `RSA`, `ECDSA`, `ED25519`.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "Unique identifier for this data source: hexadecimal representation of the SHA1 checksum of the data source.\n",
                        "type": "string"
                    },
                    "privateKeyOpenssh": {
                        "description": "The private key (in  [OpenSSH PEM (RFC 4716)](https://datatracker.ietf.org/doc/html/rfc4716) format) to extract the public key from. This is *mutually exclusive* with `private_key_pem`. Currently-supported algorithms for keys are: `RSA`, `ECDSA`, `ED25519`.\n",
                        "secret": true,
                        "type": "string"
                    },
                    "privateKeyPem": {
                        "description": "The private key (in [PEM (RFC 1421)](https://datatracker.ietf.org/doc/html/rfc1421) format) to extract the public key from. This is *mutually exclusive* with `private_key_openssh`. Currently-supported algorithms for keys are: `RSA`, `ECDSA`, `ED25519`.\n",
                        "secret": true,
                        "type": "string"
                    },
                    "publicKeyFingerprintMd5": {
                        "description": "The fingerprint of the public key data in OpenSSH MD5 hash format, e.g. `aa:bb:cc:...`. Only available if the selected private key format is compatible, as per the rules for `public_key_openssh` and ECDSA P224 limitations.\n",
                        "type": "string"
                    },
                    "publicKeyFingerprintSha256": {
                        "description": "The fingerprint of the public key data in OpenSSH SHA256 hash format, e.g. `SHA256:...`. Only available if the selected private key format is compatible, as per the rules for `public_key_openssh` and ECDSA P224 limitations.\n",
                        "type": "string"
                    },
                    "publicKeyOpenssh": {
                        "description": "The public key, in  OpenSSH PEM (RFC 4716).\n",
                        "type": "string"
                    },
                    "publicKeyPem": {
                        "description": "The public key, in PEM (RFC 1421).\n",
                        "type": "string"
                    }
                },
                "required": [
                    "algorithm",
                    "id",
                    "publicKeyFingerprintMd5",
                    "publicKeyFingerprintSha256",
                    "publicKeyOpenssh",
                    "publicKeyPem"
                ],
                "type": "object"
            }
        }
    }
}