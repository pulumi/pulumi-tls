{
    "name": "tls",
    "description": "A Pulumi package to create TLS resources in Pulumi programs.",
    "keywords": [
        "pulumi",
        "tls"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`tls` Terraform Provider](https://github.com/terraform-providers/terraform-provider-tls).",
    "repository": "https://github.com/pulumi/pulumi-tls",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "config": {},
    "types": {
        "tls:index/CertRequestSubject:CertRequestSubject": {
            "properties": {
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "country": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "locality": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organizationalUnit": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "province": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serialNumber": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "streetAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "tls:index/SelfSignedCertSubject:SelfSignedCertSubject": {
            "properties": {
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "country": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "locality": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organizationalUnit": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "province": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serialNumber": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "streetAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "tls:index/getCertificateCertificate:getCertificateCertificate": {
            "properties": {
                "isCa": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "issuer": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "notAfter": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "notBefore": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "publicKeyAlgorithm": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serialNumber": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sha1Fingerprint": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "subject": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "version": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "isCa",
                "issuer",
                "notAfter",
                "notBefore",
                "publicKeyAlgorithm",
                "serialNumber",
                "sha1Fingerprint",
                "signatureAlgorithm",
                "subject",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the tls package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n"
    },
    "resources": {
        "tls:index/certRequest:CertRequest": {
            "properties": {
                "certRequestPem": {
                    "type": "string",
                    "description": "The certificate request data in PEM format.\n"
                },
                "dnsNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of DNS names for which a certificate is being requested.\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses for which a certificate is being requested.\n"
                },
                "keyAlgorithm": {
                    "type": "string",
                    "description": "The name of the algorithm for the key provided\nin `private_key_pem`.\n"
                },
                "privateKeyPem": {
                    "type": "string",
                    "description": "PEM-encoded private key that the certificate will belong to\n"
                },
                "subjects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/tls:index/CertRequestSubject:CertRequestSubject"
                    },
                    "description": "The subject for which a certificate is being requested. This is\na nested configuration block whose structure is described below.\n"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of URIs for which a certificate is being requested.\n"
                }
            },
            "required": [
                "certRequestPem",
                "keyAlgorithm",
                "privateKeyPem",
                "subjects"
            ],
            "inputProperties": {
                "dnsNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of DNS names for which a certificate is being requested.\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses for which a certificate is being requested.\n"
                },
                "keyAlgorithm": {
                    "type": "string",
                    "description": "The name of the algorithm for the key provided\nin `private_key_pem`.\n"
                },
                "privateKeyPem": {
                    "type": "string",
                    "description": "PEM-encoded private key that the certificate will belong to\n"
                },
                "subjects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/tls:index/CertRequestSubject:CertRequestSubject"
                    },
                    "description": "The subject for which a certificate is being requested. This is\na nested configuration block whose structure is described below.\n"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of URIs for which a certificate is being requested.\n"
                }
            },
            "requiredInputs": [
                "keyAlgorithm",
                "privateKeyPem",
                "subjects"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CertRequest resources.\n",
                "properties": {
                    "certRequestPem": {
                        "type": "string",
                        "description": "The certificate request data in PEM format.\n"
                    },
                    "dnsNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of DNS names for which a certificate is being requested.\n"
                    },
                    "ipAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of IP addresses for which a certificate is being requested.\n"
                    },
                    "keyAlgorithm": {
                        "type": "string",
                        "description": "The name of the algorithm for the key provided\nin `private_key_pem`.\n"
                    },
                    "privateKeyPem": {
                        "type": "string",
                        "description": "PEM-encoded private key that the certificate will belong to\n"
                    },
                    "subjects": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/tls:index/CertRequestSubject:CertRequestSubject"
                        },
                        "description": "The subject for which a certificate is being requested. This is\na nested configuration block whose structure is described below.\n"
                    },
                    "uris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of URIs for which a certificate is being requested.\n"
                    }
                },
                "type": "object"
            }
        },
        "tls:index/locallySignedCert:LocallySignedCert": {
            "properties": {
                "allowedUses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of keywords each describing a use that is permitted\nfor the issued certificate. The valid keywords are listed below.\n"
                },
                "caCertPem": {
                    "type": "string",
                    "description": "PEM-encoded certificate data for the CA.\n"
                },
                "caKeyAlgorithm": {
                    "type": "string",
                    "description": "The name of the algorithm for the key provided\nin `ca_private_key_pem`.\n"
                },
                "caPrivateKeyPem": {
                    "type": "string",
                    "description": "PEM-encoded private key data for the CA.\nThis can be read from a separate file using the ``file`` interpolation\nfunction.\n"
                },
                "certPem": {
                    "type": "string",
                    "description": "The certificate data in PEM format.\n"
                },
                "certRequestPem": {
                    "type": "string",
                    "description": "PEM-encoded request certificate data.\n"
                },
                "earlyRenewalHours": {
                    "type": "integer",
                    "description": "Number of hours before the certificates expiry when a new certificate will be generated\n"
                },
                "isCaCertificate": {
                    "type": "boolean",
                    "description": "Boolean controlling whether the CA flag will be set in the\ngenerated certificate. Defaults to `false`, meaning that the certificate does not represent\na certificate authority.\n"
                },
                "readyForRenewal": {
                    "type": "boolean"
                },
                "setSubjectKeyId": {
                    "type": "boolean",
                    "description": "If `true`, the certificate will include\nthe subject key identifier. Defaults to `false`, in which case the subject\nkey identifier is not set at all.\n"
                },
                "validityEndTime": {
                    "type": "string",
                    "description": "The time until which the certificate is invalid, as an\n[RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                },
                "validityPeriodHours": {
                    "type": "integer",
                    "description": "The number of hours after initial issuing that the\ncertificate will become invalid.\n"
                },
                "validityStartTime": {
                    "type": "string",
                    "description": "The time after which the certificate is valid, as an\n[RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                }
            },
            "required": [
                "allowedUses",
                "caCertPem",
                "caKeyAlgorithm",
                "caPrivateKeyPem",
                "certPem",
                "certRequestPem",
                "readyForRenewal",
                "validityEndTime",
                "validityPeriodHours",
                "validityStartTime"
            ],
            "inputProperties": {
                "allowedUses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of keywords each describing a use that is permitted\nfor the issued certificate. The valid keywords are listed below.\n"
                },
                "caCertPem": {
                    "type": "string",
                    "description": "PEM-encoded certificate data for the CA.\n"
                },
                "caKeyAlgorithm": {
                    "type": "string",
                    "description": "The name of the algorithm for the key provided\nin `ca_private_key_pem`.\n"
                },
                "caPrivateKeyPem": {
                    "type": "string",
                    "description": "PEM-encoded private key data for the CA.\nThis can be read from a separate file using the ``file`` interpolation\nfunction.\n"
                },
                "certRequestPem": {
                    "type": "string",
                    "description": "PEM-encoded request certificate data.\n"
                },
                "earlyRenewalHours": {
                    "type": "integer",
                    "description": "Number of hours before the certificates expiry when a new certificate will be generated\n"
                },
                "isCaCertificate": {
                    "type": "boolean",
                    "description": "Boolean controlling whether the CA flag will be set in the\ngenerated certificate. Defaults to `false`, meaning that the certificate does not represent\na certificate authority.\n"
                },
                "setSubjectKeyId": {
                    "type": "boolean",
                    "description": "If `true`, the certificate will include\nthe subject key identifier. Defaults to `false`, in which case the subject\nkey identifier is not set at all.\n"
                },
                "validityPeriodHours": {
                    "type": "integer",
                    "description": "The number of hours after initial issuing that the\ncertificate will become invalid.\n"
                }
            },
            "requiredInputs": [
                "allowedUses",
                "caCertPem",
                "caKeyAlgorithm",
                "caPrivateKeyPem",
                "certRequestPem",
                "validityPeriodHours"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LocallySignedCert resources.\n",
                "properties": {
                    "allowedUses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of keywords each describing a use that is permitted\nfor the issued certificate. The valid keywords are listed below.\n"
                    },
                    "caCertPem": {
                        "type": "string",
                        "description": "PEM-encoded certificate data for the CA.\n"
                    },
                    "caKeyAlgorithm": {
                        "type": "string",
                        "description": "The name of the algorithm for the key provided\nin `ca_private_key_pem`.\n"
                    },
                    "caPrivateKeyPem": {
                        "type": "string",
                        "description": "PEM-encoded private key data for the CA.\nThis can be read from a separate file using the ``file`` interpolation\nfunction.\n"
                    },
                    "certPem": {
                        "type": "string",
                        "description": "The certificate data in PEM format.\n"
                    },
                    "certRequestPem": {
                        "type": "string",
                        "description": "PEM-encoded request certificate data.\n"
                    },
                    "earlyRenewalHours": {
                        "type": "integer",
                        "description": "Number of hours before the certificates expiry when a new certificate will be generated\n"
                    },
                    "isCaCertificate": {
                        "type": "boolean",
                        "description": "Boolean controlling whether the CA flag will be set in the\ngenerated certificate. Defaults to `false`, meaning that the certificate does not represent\na certificate authority.\n"
                    },
                    "readyForRenewal": {
                        "type": "boolean"
                    },
                    "setSubjectKeyId": {
                        "type": "boolean",
                        "description": "If `true`, the certificate will include\nthe subject key identifier. Defaults to `false`, in which case the subject\nkey identifier is not set at all.\n"
                    },
                    "validityEndTime": {
                        "type": "string",
                        "description": "The time until which the certificate is invalid, as an\n[RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                    },
                    "validityPeriodHours": {
                        "type": "integer",
                        "description": "The number of hours after initial issuing that the\ncertificate will become invalid.\n"
                    },
                    "validityStartTime": {
                        "type": "string",
                        "description": "The time after which the certificate is valid, as an\n[RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                    }
                },
                "type": "object"
            }
        },
        "tls:index/privateKey:PrivateKey": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "The name of the algorithm to use for\nthe key. Currently-supported values are \"RSA\" and \"ECDSA\".\n"
                },
                "ecdsaCurve": {
                    "type": "string",
                    "description": "When `algorithm` is \"ECDSA\", the name of the elliptic\ncurve to use. May be any one of \"P224\", \"P256\", \"P384\" or \"P521\", with \"P224\" as the\ndefault.\n"
                },
                "privateKeyPem": {
                    "type": "string",
                    "description": "The private key data in PEM format.\n"
                },
                "publicKeyFingerprintMd5": {
                    "type": "string",
                    "description": "The md5 hash of the public key data in\nOpenSSH MD5 hash format, e.g. `aa:bb:cc:...`. Only available if the\nselected private key format is compatible, as per the rules for\n`public_key_openssh`.\n"
                },
                "publicKeyOpenssh": {
                    "type": "string",
                    "description": "The public key data in OpenSSH `authorized_keys`\nformat, if the selected private key format is compatible. All RSA keys\nare supported, and ECDSA keys with curves \"P256\", \"P384\" and \"P521\"\nare supported. This attribute is empty if an incompatible ECDSA curve\nis selected.\n"
                },
                "publicKeyPem": {
                    "type": "string",
                    "description": "The public key data in PEM format.\n"
                },
                "rsaBits": {
                    "type": "integer",
                    "description": "When `algorithm` is \"RSA\", the size of the generated\nRSA key in bits. Defaults to 2048.\n"
                }
            },
            "required": [
                "algorithm",
                "privateKeyPem",
                "publicKeyFingerprintMd5",
                "publicKeyOpenssh",
                "publicKeyPem"
            ],
            "inputProperties": {
                "algorithm": {
                    "type": "string",
                    "description": "The name of the algorithm to use for\nthe key. Currently-supported values are \"RSA\" and \"ECDSA\".\n"
                },
                "ecdsaCurve": {
                    "type": "string",
                    "description": "When `algorithm` is \"ECDSA\", the name of the elliptic\ncurve to use. May be any one of \"P224\", \"P256\", \"P384\" or \"P521\", with \"P224\" as the\ndefault.\n"
                },
                "rsaBits": {
                    "type": "integer",
                    "description": "When `algorithm` is \"RSA\", the size of the generated\nRSA key in bits. Defaults to 2048.\n"
                }
            },
            "requiredInputs": [
                "algorithm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivateKey resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "The name of the algorithm to use for\nthe key. Currently-supported values are \"RSA\" and \"ECDSA\".\n"
                    },
                    "ecdsaCurve": {
                        "type": "string",
                        "description": "When `algorithm` is \"ECDSA\", the name of the elliptic\ncurve to use. May be any one of \"P224\", \"P256\", \"P384\" or \"P521\", with \"P224\" as the\ndefault.\n"
                    },
                    "privateKeyPem": {
                        "type": "string",
                        "description": "The private key data in PEM format.\n"
                    },
                    "publicKeyFingerprintMd5": {
                        "type": "string",
                        "description": "The md5 hash of the public key data in\nOpenSSH MD5 hash format, e.g. `aa:bb:cc:...`. Only available if the\nselected private key format is compatible, as per the rules for\n`public_key_openssh`.\n"
                    },
                    "publicKeyOpenssh": {
                        "type": "string",
                        "description": "The public key data in OpenSSH `authorized_keys`\nformat, if the selected private key format is compatible. All RSA keys\nare supported, and ECDSA keys with curves \"P256\", \"P384\" and \"P521\"\nare supported. This attribute is empty if an incompatible ECDSA curve\nis selected.\n"
                    },
                    "publicKeyPem": {
                        "type": "string",
                        "description": "The public key data in PEM format.\n"
                    },
                    "rsaBits": {
                        "type": "integer",
                        "description": "When `algorithm` is \"RSA\", the size of the generated\nRSA key in bits. Defaults to 2048.\n"
                    }
                },
                "type": "object"
            }
        },
        "tls:index/selfSignedCert:SelfSignedCert": {
            "properties": {
                "allowedUses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of keywords each describing a use that is permitted\nfor the issued certificate. The valid keywords are listed below.\n"
                },
                "certPem": {
                    "type": "string",
                    "description": "The certificate data in PEM format.\n"
                },
                "dnsNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of DNS names for which a certificate is being requested.\n"
                },
                "earlyRenewalHours": {
                    "type": "integer",
                    "description": "Number of hours before the certificates expiry when a new certificate will be generated\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses for which a certificate is being requested.\n"
                },
                "isCaCertificate": {
                    "type": "boolean",
                    "description": "Boolean controlling whether the CA flag will be set in the\ngenerated certificate. Defaults to `false`, meaning that the certificate does not represent\na certificate authority.\n"
                },
                "keyAlgorithm": {
                    "type": "string",
                    "description": "The name of the algorithm for the key provided\nin `private_key_pem`.\n"
                },
                "privateKeyPem": {
                    "type": "string",
                    "description": "PEM-encoded private key that the certificate will belong to\n"
                },
                "readyForRenewal": {
                    "type": "boolean"
                },
                "setSubjectKeyId": {
                    "type": "boolean",
                    "description": "If `true`, the certificate will include\nthe subject key identifier. Defaults to `false`, in which case the subject\nkey identifier is not set at all.\n"
                },
                "subjects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/tls:index/SelfSignedCertSubject:SelfSignedCertSubject"
                    },
                    "description": "The subject for which a certificate is being requested.\nThis is a nested configuration block whose structure matches the\ncorresponding block for `tls.CertRequest`.\n"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of URIs for which a certificate is being requested.\n"
                },
                "validityEndTime": {
                    "type": "string",
                    "description": "The time until which the certificate is invalid, as an\n[RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                },
                "validityPeriodHours": {
                    "type": "integer",
                    "description": "The number of hours after initial issuing that the\ncertificate will become invalid.\n"
                },
                "validityStartTime": {
                    "type": "string",
                    "description": "The time after which the certificate is valid, as an\n[RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                }
            },
            "required": [
                "allowedUses",
                "certPem",
                "keyAlgorithm",
                "privateKeyPem",
                "readyForRenewal",
                "subjects",
                "validityEndTime",
                "validityPeriodHours",
                "validityStartTime"
            ],
            "inputProperties": {
                "allowedUses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of keywords each describing a use that is permitted\nfor the issued certificate. The valid keywords are listed below.\n"
                },
                "dnsNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of DNS names for which a certificate is being requested.\n"
                },
                "earlyRenewalHours": {
                    "type": "integer",
                    "description": "Number of hours before the certificates expiry when a new certificate will be generated\n"
                },
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses for which a certificate is being requested.\n"
                },
                "isCaCertificate": {
                    "type": "boolean",
                    "description": "Boolean controlling whether the CA flag will be set in the\ngenerated certificate. Defaults to `false`, meaning that the certificate does not represent\na certificate authority.\n"
                },
                "keyAlgorithm": {
                    "type": "string",
                    "description": "The name of the algorithm for the key provided\nin `private_key_pem`.\n"
                },
                "privateKeyPem": {
                    "type": "string",
                    "description": "PEM-encoded private key that the certificate will belong to\n"
                },
                "setSubjectKeyId": {
                    "type": "boolean",
                    "description": "If `true`, the certificate will include\nthe subject key identifier. Defaults to `false`, in which case the subject\nkey identifier is not set at all.\n"
                },
                "subjects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/tls:index/SelfSignedCertSubject:SelfSignedCertSubject"
                    },
                    "description": "The subject for which a certificate is being requested.\nThis is a nested configuration block whose structure matches the\ncorresponding block for `tls.CertRequest`.\n"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of URIs for which a certificate is being requested.\n"
                },
                "validityPeriodHours": {
                    "type": "integer",
                    "description": "The number of hours after initial issuing that the\ncertificate will become invalid.\n"
                }
            },
            "requiredInputs": [
                "allowedUses",
                "keyAlgorithm",
                "privateKeyPem",
                "subjects",
                "validityPeriodHours"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SelfSignedCert resources.\n",
                "properties": {
                    "allowedUses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of keywords each describing a use that is permitted\nfor the issued certificate. The valid keywords are listed below.\n"
                    },
                    "certPem": {
                        "type": "string",
                        "description": "The certificate data in PEM format.\n"
                    },
                    "dnsNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of DNS names for which a certificate is being requested.\n"
                    },
                    "earlyRenewalHours": {
                        "type": "integer",
                        "description": "Number of hours before the certificates expiry when a new certificate will be generated\n"
                    },
                    "ipAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of IP addresses for which a certificate is being requested.\n"
                    },
                    "isCaCertificate": {
                        "type": "boolean",
                        "description": "Boolean controlling whether the CA flag will be set in the\ngenerated certificate. Defaults to `false`, meaning that the certificate does not represent\na certificate authority.\n"
                    },
                    "keyAlgorithm": {
                        "type": "string",
                        "description": "The name of the algorithm for the key provided\nin `private_key_pem`.\n"
                    },
                    "privateKeyPem": {
                        "type": "string",
                        "description": "PEM-encoded private key that the certificate will belong to\n"
                    },
                    "readyForRenewal": {
                        "type": "boolean"
                    },
                    "setSubjectKeyId": {
                        "type": "boolean",
                        "description": "If `true`, the certificate will include\nthe subject key identifier. Defaults to `false`, in which case the subject\nkey identifier is not set at all.\n"
                    },
                    "subjects": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/tls:index/SelfSignedCertSubject:SelfSignedCertSubject"
                        },
                        "description": "The subject for which a certificate is being requested.\nThis is a nested configuration block whose structure matches the\ncorresponding block for `tls.CertRequest`.\n"
                    },
                    "uris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of URIs for which a certificate is being requested.\n"
                    },
                    "validityEndTime": {
                        "type": "string",
                        "description": "The time until which the certificate is invalid, as an\n[RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                    },
                    "validityPeriodHours": {
                        "type": "integer",
                        "description": "The number of hours after initial issuing that the\ncertificate will become invalid.\n"
                    },
                    "validityStartTime": {
                        "type": "string",
                        "description": "The time after which the certificate is valid, as an\n[RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "tls:index/getCertificate:getCertificate": {
            "description": "Use this data source to get information, such as SHA1 fingerprint or serial number, about the TLS certificates that\nprotect an HTTPS website. Note that the certificate chain isn't verified.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as tls from \"@pulumi/tls\";\n\nconst exampleCluster = new aws.eks.Cluster(\"example\", {});\nconst exampleCertificate = exampleCluster.identities.apply(identities =\u003e tls.getCertificate({\n    url: identities[0].oidcs[0].issuer,\n}, { async: true }));\nconst exampleOpenIdConnectProvider = new aws.iam.OpenIdConnectProvider(\"example\", {\n    clientIdLists: [\"sts.amazonaws.com\"],\n    thumbprintLists: [exampleCertificate.certificates[0].sha1Fingerprint],\n    url: exampleCluster.identities[0].oidcs[0].issuer,\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_tls as tls\n\nexample_cluster = aws.eks.Cluster(\"exampleCluster\")\nexample_certificate = example_cluster.identities.apply(lambda identities: tls.get_certificate(url=identities[0].oidcs[0].issuer))\nexample_open_id_connect_provider = aws.iam.OpenIdConnectProvider(\"exampleOpenIdConnectProvider\",\n    client_id_lists=[\"sts.amazonaws.com\"],\n    thumbprint_lists=[example_certificate.certificates[0].sha1_fingerprint],\n    url=example_cluster.identities[0].oidcs[0].issuer)\n```\n```csharp\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Tls = Pulumi.Tls;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleCluster = new Aws.Eks.Cluster(\"exampleCluster\", new Aws.Eks.ClusterArgs\n        {\n        });\n        var exampleCertificate = exampleCluster.Identities.Apply(identities =\u003e Tls.GetCertificate.InvokeAsync(new Tls.GetCertificateArgs\n        {\n            Url = identities[0].Oidcs?[0]?.Issuer,\n        }));\n        var exampleOpenIdConnectProvider = new Aws.Iam.OpenIdConnectProvider(\"exampleOpenIdConnectProvider\", new Aws.Iam.OpenIdConnectProviderArgs\n        {\n            ClientIdLists = \n            {\n                \"sts.amazonaws.com\",\n            },\n            ThumbprintLists = \n            {\n                exampleCertificate.Apply(exampleCertificate =\u003e exampleCertificate.Certificates[0].Sha1Fingerprint),\n            },\n            Url = exampleCluster.Identities.Apply(identities =\u003e identities[0].Oidcs?[0]?.Issuer),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v3/go/aws/eks\"\n\t\"github.com/pulumi/pulumi-aws/sdk/v3/go/aws/iam\"\n\t\"github.com/pulumi/pulumi-tls/sdk/v2/go/tls\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleCluster, err := eks.NewCluster(ctx, \"exampleCluster\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = iam.NewOpenIdConnectProvider(ctx, \"exampleOpenIdConnectProvider\", \u0026iam.OpenIdConnectProviderArgs{\n\t\t\tClientIdLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"sts.amazonaws.com\"),\n\t\t\t},\n\t\t\tThumbprintLists: pulumi.StringArray{\n\t\t\t\texampleCertificate.ApplyT(func(exampleCertificate tls.GetCertificateResult) (string, error) {\n\t\t\t\t\treturn exampleCertificate.Certificates[0].Sha1Fingerprint, nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t\tUrl: pulumi.String(exampleCluster.Identities.ApplyT(func(identities []eks.ClusterIdentity) (string, error) {\n\t\t\t\treturn identities[0].Oidcs[0].Issuer, nil\n\t\t\t}).(pulumi.StringOutput)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getCertificate.\n",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "The URL of the website to get the certificates from.\n"
                    },
                    "verifyChain": {
                        "type": "boolean",
                        "description": "Whether to verify the certificate chain while parsing it or not\n"
                    }
                },
                "type": "object",
                "required": [
                    "url"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCertificate.\n",
                "properties": {
                    "certificates": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/tls:index/getCertificateCertificate:getCertificateCertificate"
                        },
                        "description": "The certificates protecting the site, with the root of the chain first.\n* `certificates.#.not_after` - The time until which the certificate is invalid, as an\n[RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n* `certificates.#.not_before` - The time after which the certificate is valid, as an\n[RFC3339](https://tools.ietf.org/html/rfc3339) timestamp.\n* `certificates.#.is_ca` - `true` if this certificate is a ca certificate.\n* `certificates.#.issuer` - Who verified and signed the certificate, roughly following\n[RFC2253](https://tools.ietf.org/html/rfc2253).\n* `certificates.#.public_key_algorithm` - The algorithm used to create the certificate.\n* `certificates.#.serial_number` - Number that uniquely identifies the certificate with the CA's system. The `format`\nfunction can be used to convert this base 10 number into other bases, such as hex.\n* `certificates.#.sha1_fingerprint` - The SHA1 fingerprint of the public key of the certificate.\n* `certificates.#.signature_algorithm` - The algorithm used to sign the certificate.\n* `certificates.#.subject` - The entity the certificate belongs to, roughly following\n[RFC2253](https://tools.ietf.org/html/rfc2253).\n* `certificates.#.version` - The version the certificate is in.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "url": {
                        "type": "string"
                    },
                    "verifyChain": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "certificates",
                    "url",
                    "id"
                ]
            }
        },
        "tls:index/getPublicKey:getPublicKey": {
            "description": "Use this data source to get the public key from a PEM-encoded private key for use in other\nresources.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as tls from \"@pulumi/tls\";\n\nconst example = pulumi.output(tls.getPublicKey({\n    privateKeyPem: fs.readFileSync(\"~/.ssh/id_rsa\", \"utf-8\"),\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_tls as tls\n\nexample = tls.get_public_key(private_key_pem=(lambda path: open(path).read())(\"~/.ssh/id_rsa\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Tls = Pulumi.Tls;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Tls.GetPublicKey.InvokeAsync(new Tls.GetPublicKeyArgs\n        {\n            PrivateKeyPem = File.ReadAllText(\"~/.ssh/id_rsa\"),\n        }));\n    }\n\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getPublicKey.\n",
                "properties": {
                    "privateKeyPem": {
                        "type": "string",
                        "description": "The private key to use. Currently-supported key types are \"RSA\" or \"ECDSA\".\n"
                    }
                },
                "type": "object",
                "required": [
                    "privateKeyPem"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPublicKey.\n",
                "properties": {
                    "algorithm": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "privateKeyPem": {
                        "type": "string",
                        "description": "The private key data in PEM format.\n"
                    },
                    "publicKeyFingerprintMd5": {
                        "type": "string",
                        "description": "The md5 hash of the public key data in\nOpenSSH MD5 hash format, e.g. `aa:bb:cc:...`. Only available if the\nselected private key format is compatible, as per the rules for\n`public_key_openssh`.\n"
                    },
                    "publicKeyOpenssh": {
                        "type": "string",
                        "description": "The public key data in OpenSSH `authorized_keys`\nformat, if the selected private key format is compatible. All RSA keys\nare supported, and ECDSA keys with curves \"P256\", \"P384\" and \"P521\"\nare supported. This attribute is empty if an incompatible ECDSA curve\nis selected.\n"
                    },
                    "publicKeyPem": {
                        "type": "string",
                        "description": "The public key data in PEM format.\n"
                    }
                },
                "type": "object",
                "required": [
                    "algorithm",
                    "privateKeyPem",
                    "publicKeyFingerprintMd5",
                    "publicKeyOpenssh",
                    "publicKeyPem",
                    "id"
                ]
            }
        }
    },
    "language": {
        "csharp": {
            "namespaces": {
                "tls": "Tls"
            },
            "packageReferences": {
                "Pulumi": "2.*",
                "System.Collections.Immutable": "1.6.0"
            }
        },
        "nodejs": {
            "dependencies": {
                "@pulumi/pulumi": "^2.0.0"
            },
            "devDependencies": {
                "@types/node": "^8.0.25"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package to create TLS resources in Pulumi programs.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/terraform-providers/terraform-provider-tls)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-tls` repo](https://github.com/pulumi/pulumi-tls/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-providers/terraform-provider-tls` repo](https://github.com/terraform-providers/terraform-provider-tls/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/terraform-providers/terraform-provider-tls)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-tls` repo](https://github.com/pulumi/pulumi-tls/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-providers/terraform-provider-tls` repo](https://github.com/terraform-providers/terraform-provider-tls/issues).",
            "requires": {
                "pulumi": "\u003e=2.9.0,\u003c3.0.0"
            }
        }
    }
}